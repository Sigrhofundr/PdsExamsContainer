<h1>Esame del 22 Gennaio 2024</h1>

1. **Gestione della memoria virtuale: Paging**

Nel contesto della gestione della memoria virtuale, si consideri un sistema con uno schema di paging:

A - **D** - Definire cos'è un "page fault" (errore di pagina), spiegare le condizioni in cui si verifica un page fault e le 
conseguenze per il sistema operativo.<br>
**R** - Un page fault è un errore che si verifica quando un processo tenta l'accesso a una pagina che non era stata caricata in memoria.
Questo accade perché nei calcolatori moderni, si è capito che non era ottimale caricare in memoria tutte le pagine relative 
al programma desiderato, dato che in molti caso alcune parti vengono usate raramente. Ciò ha portato allo sviluppo della paginazione su
 richiesta. L'hardware che si occupa di questa paginazione, noterà che il bit di validità della pagina corrispondente risulterà
 invalido, ciò genererà un trap per il SO. A questo punto il SO dovrà provvedere al caricamento in memoria, individuando un frame 
libero per il caricamento, quindi eseguendo l'operazione I/O necessaria. Il SO, durante questo procedimento, può decidere 
di eseguire nel frattempo un altro processo, implementando così il multitasking e ottimizzando l'utilizzo della CPU 
durante i tempi, solitamente più lunghi, delle operazioni I/O.

B - **D** - Elencare i passaggi coinvolti nella gestione di un page fault, illustrando come il sistema operativo risponde a un 
page fault e il meccanismo che impiega per risolvere questi errori.<br>
**R** - La procedura solitamente è la seguente e lineare:<br>
    1. Si controlla nella tabella interna al processo se il riferimento fosse un accesso alla memoria valido o no;<br>
    2. Se il riferimento non era valido, si termina il processo. Se era un rif valido, ma la pagina non era ancora stata portata 
in memoria, se ne effettua il caricamento;<br>
    3. Si individua un frame libero, per esempio prelevandone uno dalla lista dei frame liberi; <br>
    4. Si programma un'operazione sui dischi per trasferire la pagina desiderata nel frame appena assegnato; <br>
    5. Quando la lettura dal disco è completa, si modificano la tabella interna e la tabella delle pagine per indicare che 
la pagina si trova attualmente in memoria; <br>
    6. Si riavvia l'istruzione interrotta dall'eccezione. A questo punto il processo può accedere alla pagina come se questa 
fosse stata sempre presente in memoria;

C - **D** - Si consideri un array bidimensionale A: int A[100][100], dove A[0][0] si trova alla posizione 800 in un sistema di 
memoria paginato e byte-indirizzabile, con pagine di dimensione 800 Byte. La dimensione di un intero è di 32 bit. 
Il processo che manipola la matrice risiede nella pagina 0 (posizioni da 0 a 799). 
Pertanto, ogni recupero di istruzione (instruction fetch) avverrà dalla pagina 0. Considerando tre frame di pagina, 
quanti page fault vengono generati dal seguente ciclo di inizializzazione dell'array? Utilizzare la politica di 
sostituzione LRU (Least Recently Used) e assumere che un frame di pagina contenga il codice e gli altri due siano inizialmente vuoti.
```
1. 
for (int j=0; j <100, j++)
    for (int i = 0; i < 100; i ++){
        A[i][j] = 0;
    }
2. 
for (int i=0; i <100, i++)
    for (int j = 0; j < 100; j ++){
        A[i][j] = 0;
   }
```

**R** - Riepilogo dati:
- Array bidimensionale A[100][100] di interi a 32 bit (4B);
- Posizione iniziale: A[0][0] all'indirizzo 800;
- Dim Pagina: 800 B;
- 3 frame totali: 1 per il codice (pag 0), 2 per i dati;
- Algoritmo LRU;

- Capacità pagina: Dim Pagina / dim interi = 800 / 4 = 200 interi;
- Elementi Array : righe*colonne = 10000 elementi
- Numero pagine necessarie = Elementi array / capacità pag = 10000 /200 = 50 pagine per l'intero array;
  
- Disposizione in memoria:
  In un array bidimensionale in C, gli elementi sono memorizzati row-major order (per righe):

A[0][0], A[0][1], ..., A[0][99], A[1][0], A[1][1], ...



Il primo ciclo indica un accesso per colonne, che causerà parecchi page fault dato che ogni accesso potrebbe richiedere 
una pagina diversa; il secondo invece accede agli elementi in ordine sequenziale, sfruttando meglio la località spaziale, 
causando quindi meno page fault. Avendo a disposizione solo 2 frame disponibili per i dati, il numero di page fault aumenterà.

Nella prima matrice:
- scorrendo per colonne, avremo:

- Mappatura pagine:

Pagina 1: A[0][0] ... A[0][99], A[1][0] ... A[1][99]  (righe 0-1)
Pagina 2: A[2][0] ... A[2][99], A[3][0] ... A[3][99]  (righe 2-3)
Pagina 3: A[4][0] ... A[4][99], A[5][0] ... A[5][99]  (righe 4-5)
...
Pagina 25: A[48][0] ... A[48][99], A[49][0] ... A[49][99] (righe 48-49)
Pagina 26: A[50][0] ... A[50][99], A[51][0] ... A[51][99] (righe 50-51)
...
Pagina 50: A[98][0] ... A[98][99], A[99][0] ... A[99][99] (righe 98-99)

Formula per Calcolare la Pagina
Per un elemento A[i][j]: pagina = (i / 2) + 1 (divisione intera)

- Analisi dei page fault:
  - per j = 0 (prima colonna):
  - A[0][0] → Pagina 1 (page fault - carica pagina 1)
    A[1][0] → Pagina 1 (già in memoria)
    A[2][0] → Pagina 2 (page fault - carica pagina 2)
    A[3][0] → Pagina 2 (già in memoria)
    A[4][0] → Pagina 3 (page fault - carica pagina 3, sostituisce pagina 1 con LRU)
    A[5][0] → Pagina 3 (già in memoria)
    A[6][0] → Pagina 4 (page fault - carica pagina 4, sostituisce pagina 2 con LRU)
    ...
- da ciò emerge che:
- ogni 2 accessi consecutivi, serve una nuova pagina;
- con solo 2 frame disponibili, si ha un page fault ogni 2 accessi dopo i primi 4;
- i primi 4 accessi generano 3 page fault per riempire i frame;
- dopo, ogni nuovo accesso a una pagina non presente causa sostituzione;

Quindi, per ogni colonna j:
- si accede a tutte le 100 righe (50 pagine diverse);
- Pattern: 2 accessi senza PF, poi 1 PF, 1 accesso senza PF, poi 1 PF...

50 pagine × 100 colonne = 5000 "visite"
Con solo 2 frame e 50 pagine da visitare per colonna, ogni visita genera sostanzialmente un page fault
PF per matrice 1 = 50*100 = 5000;

Nella seconda matrice:

- l'accesso è sequenziale per righe. Ogni pagina contiene 2 righe complete. 
Quando processiamo una coppia di righe, generiamo 1 page fault per caricare la pagina, poi tutti gli accessi successivi 
nella stessa pagina sono hit. Con 50 coppie di righe, otteniamo 50 page fault totali.

2. **RAID**

A) **D** - Spiega la struttura RAID, discuti i suoi benefici, spiegando come il livello RAID scelto migliora l'archiviazione e 
il recupero dei dati rispetto a un singolo disco. <br>
**R** - La presenza di più dischi, se il sistema ne permette l'uso in parallelo, rende possibile la frequenza a cui i dati 
si possono leggere e scrivere. Una configurazione di questo tipo permette di migliore l'affidabilità della memoria secondaria, 
poiché diventa possibile memorizzare le informazioni in più dischi in modo ridondante. In questo modo, un guasto a uno dei 
dischi non comporta la perdita immediata dei dati. Esistono delle tecniche per l'organizzazione dei dischi, note col nome di "batterie 
ridondanti di dischi" (redundant array of independent disks, RAID), che hanno lo scopo di affrontare i problemi di prestazione 
e affidabilità. Come accennato in precedenza, la ridondanza permette di migliorare l'affidabilità dei dischi. Una delle tecniche 
consiste nel mirroring, ovvero la duplicazioni del disco in una o più copie identiche al disco originale. (si potrebbe andare più a fondo 
al riguardo ma non è richiesto). Il miglioramento delle prestazioni come detto può essere dato dal parallelismo tramite il sezionamento o 
striping a livello dei bit, distribuendo i dati in sezioni su più dispositivi. I numerosi schemi per fornire la ridondanza a basso costo, sono stati 
divisi in base a costi e prestazioni e sono stati classificati in livelli chiamati livelli RAID. I livelli RAID consistono in dei livelli numerati da 
0 a 6 e poi in diverse combinazioni annidate. Alcuni esempi:
- RAID 0 - Divide i dati in blocchi (striping) e li distribuisce su più dischi, aumentando le prestazioni di lettura e scrittura. 
Non offre ridondanza, quindi il guasto di un solo disco comporta la perdita di tutti i dati.
- RAID 1 - Duplica esattamente i dati su due o più dischi (mirroring), garantendo un'elevata tolleranza ai guasti. 
La capacità utilizzabile è pari a quella di un singolo disco, poiché gli altri sono copie.
- RAID 5 - Utilizza lo striping dei dati con parità distribuita su tutti i dischi. Offre un buon equilibrio tra 
 prestazioni, ridondanza (può tollerare il guasto di un disco) e utilizzo dello spazio.
- RAID 6 - Simile al RAID 5, ma con doppia parità distribuita, che consente di tollerare il guasto 
contemporaneo di due dischi. Questo aumenta la sicurezza dei dati a discapito di prestazioni di scrittura leggermente inferiori.
- RAID 10 (1+0) - Combina il mirroring (RAID 1) con lo striping (RAID 0). I dati vengono prima specchiati in coppie di 
dischi e poi questi set specchiati vengono strippati, offrendo prestazioni elevate e un'ottima tolleranza ai guasti.

Miglioramenti rispetto a Disco Singolo
Rispetto a un singolo disco, RAID offre throughput moltiplicato per il numero di dischi (in lettura), riduzione drastica 
del rischio di perdita dati, continuità operativa durante guasti hardware, e flessibilità nella scelta del compromesso tra prestazioni, sicurezza e costo.
Recap: RAID trasforma più dischi fisici in un sistema logico che supera i limiti di prestazioni e affidabilità dei 
singoli dischi, offrendo soluzioni scalabili per diverse esigenze aziendali attraverso livelli configurabili che 
bilanciano velocità, sicurezza e capacità utilizzabile.


A-Bis) <!--Perché compare nella soluzione ma non nel testo --> **D** - Spiega nel dettaglio, RAID 1, mirroring:
**R** - è un livello RAID che garantisce la ridondanza completa dei dati. Funziona creando una copia esatta (mirror) di 
tutti i dati su due o più dischi. Questo significa che ogni informazione scritta su un disco viene contemporaneamente 
replicata sull'altro (o sugli altri) dischi dell'array. Il vantaggio principale è un'elevatissima tolleranza ai guasti: 
se un disco si rompe, i dati sono immediatamente disponibili sull'altro disco, senza interruzioni. Tuttavia, la capacità 
utilizzabile del sistema è pari a quella del singolo disco più piccolo, poiché gli altri dischi vengono usati per la duplicazione.

B) **D** - Nel contesto della struttura RAID, definisci il tempo medio al guasto (MTTF), il tempo medio di perdita 
dei dati (MTTDL) e il tempo medio di riparazione (MTTR). Fornisci una spiegazione di ciascun termine ed elabora come 
queste metriche contribuiscono all'affidabilità complessiva e alla disponibilità di un sistema RAID.<br>
**R** Metriche di Affidabilità RAID <br>
Definizioni:<br>
- MTTF (Mean Time To Failure): Tempo medio che intercorre prima che un disco si guasti in modo irrecuperabile. 
Per sistemi RAID, rappresenta l'affidabilità dei singoli componenti e si misura tipicamente in anni.<br>
- MTTDL (Mean Time To Data Loss): Tempo medio necessario perché il sistema subisca una perdita permanente di 
dati dovuta a guasti dei dischi. Dipende dal livello RAID e dalla sua capacità di tollerare guasti multipli. <br>
- MTTR (Mean Time To Repair): Tempo medio richiesto per sostituire un disco guasto e ripristinare completamente l'array, 
includendo il rebuild dei dati.<br>
Relazioni e Calcoli<br>
RAID 0: MTTDL = MTTF_singolo_disco / numero_dischi (diminuisce con più dischi)<br>
RAID 1: MTTDL = MTTF^2 / (n × MTTR) (molto elevato grazie al mirroring, con N>=2)<br>
RAID 5: MTTDL = (MTTF²) / (N × MTTR) dove N è il numero di dischi (tolleranza a un guasto)<br>
Impatto sull'Affidabilità<br>
Il rapporto MTTF/MTTR determina la finestra di vulnerabilità durante le riparazioni. Un MTTR basso è 
cruciale per sistemi mission-critical, poiché riduce il tempo in cui il sistema opera in modalità degradata.<br>
La combinazione di queste metriche definisce la disponibilità complessiva del sistema e guida la scelta del 
livello RAID appropriato in base ai requisiti di uptime e protezione dei dati.

C) **D** - Considera una struttura RAID con 4 dischi in una configurazione mirror (RAID 1). 
Supponendo che ogni disco possa guastarsi indipendentemente dagli altri, con un MTTF di 50000 ore e un MTTR di 10 ore, 
calcola il MTTDL. Fornisci una spiegazione passo-passo del processo di calcolo.<br>
**R** - utilizzando la formula precedente:<br>
RAID 1: MTTDL = (MTTF²) / (4 × MTTR)  = avendo delle grandezze coerenti posso limitarmi a sostituire -> <br>
-> MTDDL = (50000^2) / 40 = 62,5M ore
Nel caso in cui abbiamo 2 o 4 dischi in una configurazione RAID 1 mirrored, il MTTDL è associato con lo scenario dove entrambi 
i dischi in ognuna delle coppie si guasta.
MTTF in un sistema a 4 tipi indipendenti è MTTF/4 e non MTTF/2
Probabilità di Guasto per Sistemi Paralleli
Quando hai n componenti indipendenti che operano in parallelo, il tempo medio al primo guasto del sistema è:
MTTF_sistema = MTTF_singolo_componente / n

3. **Gestione dello spazio libero**<br>
Considera l'uso di liste concatenate e bitmap per la gestione dello spazio libero, sia per i frame liberi (nella gestione della memoria) che per i blocchi liberi (nei file system). 
Rispondi sì/no (vero/falso) alle seguenti affermazioni e fornisci la motivazione per la risposta.

A) **D** - Le bitmap sono migliori delle liste concatenate quando si cercano intervalli di frame/blocchi contigui.<br>
**R** - Vero. Le bitmap sono generalmente migliori delle liste concatenate per trovare intervalli contigui perché 
permettono algoritmi di ricerca più efficienti (complessità logaritmica vs lineare) e offrono una vista immediata della frammentazione.<br>
B) **D** - In un sistema con paginazione, le liste di spazio libero sono la soluzione migliore sia per la memoria del processo che per la memoria del kernel.<br>
**R** - No. Rappresentano la migliore soluzione per i processi, ma non per il kernel, il quale ha bisogno dell'allocazione della memoria contigua
(per esempio per le tabelle di allocazione delle pagine), mentre i processi non ne hanno bisogno (e le linked list hanno 
complessità O(1))<br>
C) **D** - I blocchi liberi per un file system basato su i-node sono meglio gestiti con le bitmap.<br>
**R** - Falso. I file system i-node non richiedono blocchi contigui, quindi le liste concatenate offrono allocazione/liberazione 
O(1), mentre le bitmap hanno complessità maggiore anche negli algoritmi ottimizzati. Le liste sono più efficienti 
quando la contiguità non è necessaria.<br>
D) **D** - La ricerca di un blocco libero in una lista di spazio libero (concatenata) ha un costo lineare 
(rispetto alla dimensione della lista) con la gestione della memoria basata su una tabella delle pagine a due livelli.<br>
**R** - No. Le tabelle delle pagine non hanno bisogno di memoria contigua, quindi le liste hanno complessita O(1);<br>
E) **D** - Una lista di spazio libero concatenata e ordinata ha un costo lineare (rispetto alla dimensione della lista) 
sia per l'allocazione che per la liberazione di spazio contiguo.<br>
**R** - Sì. Perché liberare la memoria implica un operazione di inserimento in una lista ordinata, e un allocazione richiede 
un operazione di ricerca sulla lista: entrambe le operazioni sono lineari;<br>
F) **D** - Una bitmap, sebbene richieda memoria aggiuntiva, offre prestazioni temporali migliori (rispetto a una 
lista di spazio libero) con un file system basato su FAT (File Allocation Table).<br>
**R** - No. Perché la FAT non ha bisogno dell'allocazione contigua quindi una free list (direttamente implementata nella FAT)
 è O(1);