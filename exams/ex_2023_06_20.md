# Esame di Programmazione di Sistema (OS internals - Cabodi) - 20/06/2023

---

## Domanda 1

**IMPORTANTE:** Se i risultati sono numeri, riportare passaggi intermedi rilevanti e/o formule usate. Le risposte SI/NO vanno motivate.

Sia dato un sistema di memoria virtuale con paginazione a richiesta, nel quale vengono indirizzati i Byte.<br> 
Il sistema ha indirizzi su 32 bit, con pagine di 4KB, e dispone di TLB (Translation Look-aside Buffer). La tabella delle pagine ("page-table") è a un solo livello.<br> 
Non si utilizzano ulteriori strutture dati (quali tabelle di hash o inverted page table) per velocizzare gli accessi. Un TLB miss viene gestito facendo accesso alla tabella delle pagine, 
gestendo l'eventuale PF, aggiornando la TLB, e ripetendo l'accesso in memoria con TLB aggiornata.<br> 
Si sa che la memoria RAM ha tempo di accesso di 100 ns, che un Page Fault ha un costo di 2.1ms oppure 4.1ms, a seconda 
del valore del modify bit relativo alla pagina scelta come vittima. Si sono valutate tre stringhe di riferimento w1, w2 e w3, 
di lunghezza 100000 (ognuna). In w1 si osservano 10000 TLB miss e nessun PF, in w2 20000 TLB miss e 10 PF (tutti con modify bit 0), 
in w3 10000 TLB miss e 20 PF, di cui 10 con modify bit 0 e 10 con modify bit 1. Si sa inoltre che le tre stringhe rappresentano 
il comportamento del sistema in esame, assumendo che w2 e w3 siano equiprobabili e con probabilità (sia w2 che w3) doppia rispetto a w1.

Si risponda alle seguenti domande:

A) **D** - Si calcoli il numero complessivo di accessi alla TLB (compresi gli accessi ripetuti dopo un miss) eseguendo, in sequenza, le tre stringhe di riferimento.<br>
Si calcoli quindi, ESCLUDENDO I TEMPI DI PF, il tempo effettivo di accesso in RAM, dapprima per la sequenza delle tre stringhe e poi per il sistema che rappresentano (tenendo conto delle relative probabilità).<br>
**R** - Riepilogando i dati: <br>
Indirizzi 32 bit -> 4 B; DIM_Pagine 4 KB -> 4 * 1024 B = 4096 B = 2^12; (un livello => 12 bit page number - 20 offset?)<br>
Lunghezza_stringa_w1=Lunghezza_stringa_w2=Lunghezza_stringa_w3 = 100.000;<br>
TLB_miss_w1 = 10.000 ; PF_w1 = 0;<br>
TLB_miss_w2 = 20.000 ; PF_w2 = 10; (modify bit 0)<br>
TLB_miss_w3 = 10.000 ; PF_w3 = 20; (10 con mod_bit 0 e 10 con mod_bit 1)<br>
Probabilita: P(w2) = P(w3) = 2*P(w1)<br>
T_accesso_ram = 100ns; PF_mb_1 = 4.1 ms; PF_mb_0 = 2.1 ms<br>
<br>
Accessi_TLB_TOT = Lunghezza_stringa + TLB_Miss<br>
Accessi alla RAM (escludendo PF): per TLB hit: 1 accesso RAM (dato); per TLB Miss: 2 accessi RAM (Page table + dato)<br>
Tempo accesso effettivo per una stringa:<br>
T_acc_stringa = (TLB_hit * t_acc_RAM) + (TLB_miss * 2 * t_acc_RAM) dove TLB_hit = Lunghezza_stringa - TLB_miss<br>

<br>
Per calcolare gli accessi TLB totali, sommiamo la lunghezza della stringa ai TLB miss (per i riaccessi dopo miss).<br>
Per il tempo di accesso RAM, consideriamo che ogni TLB hit richiede 1 accesso RAM e ogni TLB miss ne richiede 2.<br>
Il tempo medio del sistema si calcola pesando i tempi di ogni stringa con le rispettive probabilità.<br>
Accessi_TLB_TOT = Lunghezza_stringa + TLB_Miss = (sommatoria delle singole stringhe)<br>
Accessi_TLB_TOT = (100.000 + 10.000) + (100.000 + 20.000) + (100.000+ 10.000) = 340.000 accessi<br>
Stringa w1:<br>
    - TLB_hit_w1 = 100.000 - 10.000 = 90.000;<br>
    - T_acc_w1 = (90.000*100*10^-9) + (10.000 * 2 * 100 * 10^-9) = (9 * 10^-3) + (2 * 10^-3) = 11 * 10^-3 s = 11 ms;<br>
Stringa w2: (ricordando che non stiamo includendo i tempi di PF, ed anche per w3)<br>
    - TLB_hit_w2 = 100.000 - 20.000 = 80.000;<br>
    - T_acc_w2 = (80.000 * 100* 10^-9 ) + (20.000 * 2 * 100 * 10^-9) = (8 * 10^-3) + (4 * 10^-3) = 12 * 10^-3 s = 12 ms;<br>
Stringa w3:<br>
    - TLB_hit_w3 = 100.000 - 10.000 = 90.000;<br>
    - T_acc_w3 = (9*10^-3) + (2 * 10^-3) = 11 * 10^-3 s = 11 ms;<br>

Tempo_effettivo_accesso_in_ram_stringhe = T_w1 + T_w2 + T_w3 = (11 +12 +11) * 10^-3 = 34ms;<br>
da Probabilita: P(w2) = P(w3) = 2*P(w1)<br> mi ricavo , per sostituzione:<br>
P(w1) = p; P(w2) = 2p; P(w3) = 2p; => TOT = p+2p+2p = 5p => p = 1/5 => P(w1) = 1/5; P(w2) = P(w3) = 2/5

Tempo medio pesato del sistema: <br>
T_medio = Sommatoria(P_i_stringa * T_i) / Sommatoria(N_accessi_i * Probabilità_i)<br>
Mi mancano ancora N_accessi_i, cioè il numero di accessi memoria per la stringa i => N_accessi = TLB_hit + (2* TLB_Miss)<br>
N_w1 =N_w3 = 90.000 + (2 * 10.000) = 110.000; N_w2 = 80.000 + (2 * 20.000) = 120.000;<br>
P_w1 * T_acc_w1 = 1/5 * 11 * 10^-3 = 2,2 ms;<br>
P_w2 * T_acc_w2 = 2/5 * 12 * 10^-3 = 4,8 ms;<br>
P_w3 * T_acc_w3 = 2/5 * 11 * 10^-3 = 4.4 ms;<br>
P_w1 * N_acc_w1 = 1/5 * 110.000 = 22.000;<br>
P_w2 * N_acc_w2 = 2/5 * 120.000 = 48.000;<br>
P_w3 * N_acc_w3 = 2/5 * 110.000 = 44.000;<br>
T_medio = (11.4 * 10^-3)/114000 = 1 * 10^-7 s = 100 ns<br>

B) Si considerino ora i PF. Si spieghi brevemente come va correlato il modify bit con i tempi di gestione dei PF. Si calcoli, per ognuna delle tre stringhe di riferimento e quindi per il sistema che rappresentano, il tempo effettivo di accesso in RAM, tenendo conto sia della TLB che dei PF.<br>
Innanzitutto, il MB è posto a 0 se la pagina in memoria è identica alla copia sul disco (page clean), 1 se è stata modificata in memoria (page dirty);<br>
La correlazione con PF sarà data da : <br>
1. Selezionare la pagina vittima;
2. - se PF ha MB = 0 => Non serve salvare la pagina vittima (è giù uguale su disco);
   - se PF ha MB = 1 => Salva pagina vittima su disco (write-back);
3. Carica nuova pagina dal disco;
4. Aggiorna page table e TLB : -> se MB 0 -> 2.1 ms, se MB 1 -> 4.1 ms

Tempo totale per stringa (con PF) => T_tot = T_accessi_normali + T_PF;<br>
dove<br>
T_acc_norm = (TLB_hit × t_RAM) + (TLB_miss × 2 × t_RAM);<br>
T_pf = (PF_clean × t_PF_clean) + (PF_dirty × t_PF_dirty)<br>
dove <br>
t_pf_clean = 2.1 ms; t_pf_dirty = 4.1ms <br>
T_pf_w1 = 0 (non ci sono PF)<br>
T_pf_w2 = (10 * 2.1 ms) + 0= 21 ms<br>
T_pf_w3 = (10 * 2.1 ms) + (10 * 4.1) = 21 ms + 41 ms = 62 ms<br>

Riprendendo i tempi calcolati in precedenza: <br>
T_acc_tot_w1 = 11 ms + 0 = 11 ms<br>
T_acc_tot_w2 = 12 ms + 21 ms = 33 ms<br>
T_acc_tot_w3 = 11 ms + 62 ms = 73 ms<br>

Ricalcoliamo il numeratore per il tempo medio: <br>
P_w1 * T_acc_tot_w1 = 1/5 * 11 * 10 ^-3 = 2.2 ms <br>
P_w2 * T_acc_tot_w2 = 2/5 * 33 * 10 ^-3 = 13.2 ms<br>
P_w3 * T_acc_tot_w3 = 2/5 * 73 * 10 ^-3 = 29.2 ms<br>

Nel denominatore useremo la lunghezza della stringa (100.000) perché vogliamo il tempo medio per riferimento alla memoria, non per accesso fisico.
T_medio_con_PF = (44.6 * 10^-3)/(P_w1 × 100.000 + P_w2 × 100.000 + P_w3 × 100.000) = (44.6 * 10^-3)/100.000 = 4,46 * 10^-7 = 446 nanosecondi<br>

---

## Domanda 2

**IMPORTANTE:** TUTTE LE RISPOSTE SÌ / NO DEVONO ESSERE MOTIVATE. QUANDO I RISULTATI SONO NUMERI, SONO NECESSARI IL RISULTATO FINALE E I RELATIVI PASSI INTERMEDI (O FORMULE).

Considerare un file system basato su allocazione indicizzata nel quale si utilizza per ogni file una lista di blocchi indice. 
ATTENZIONE: non si tratta di organizzazione Unix-UFS basata su INODE, ma solo di lista di blocchi indice. 
I puntatori/indici hanno una dimensione di 32 bit e i blocchi del disco hanno una dimensione di 4KB. 
Il file system risiede su una partizione del disco in cui 2TB sono riservati a **blocchi di dato e blocchi di indice**, 
a cui si aggiungono 2GB riservati a metadati (FCB, direttori, ecc., blocchi indice esclusi in quanto allocati insieme ai blocchi dato).

A) Calcolare la massima dimensione possibile per un file (si vuole la dimensione esatta del file).<br>
B) Dato un file binario di dimensione 8245 KB, calcolare quanti blocchi indice e blocchi di dato occupa il file. 
Calcolare anche la frammentazione interna, sia per i blocchi di dato che per quelli di indice.<br>
C) Si sa che il file (vedi domanda B) contiene una sequenza di numeri reali in formato double (64 bit per numero). 
Si calcoli fino a quale blocco di indice e a quale riga (casella) di questo occorre accedere per leggere i primi 512K (K va inteso come 2^10) numeri del file. 
(Verificare che la dimensione sia consistente).

---

## Domanda 3

**IMPORTANTE:** SE I RISULTATI SONO NUMERI, RIPORTARE PASSAGGI INTERMEDI RILEVANTI E/O FORMULE USATE. LE RISPOSTE SI/NO VANNO MOTIVATE.

Si consideri un contesto di paginazione a richiesta con sostituzione di pagine. Si risponda alle domande seguenti.

A) Spiegare brevemente per quale/i scopo/i possono essere usati, nella Page Table, i bit denominati:
* valid
* reference
* modify

B) Si tratta di bit presenti solo nella PT o anche nella TLB? (motivare).<br>
C) Si vuole realizzare una Page Table a un solo livello unica per tutti i processi. È possibile?  Se no, spiegare perché. Se sì, dire quale è il costo di una conversione pagina-frame.

---

## Domanda 4

**IMPORTANTE:** TUTTE LE RISPOSTE SÌ / NO DEVONO ESSERE MOTIVATE. QUANDO I RISULTATI SONO NUMERI, SONO NECESSARI IL RISULTATO FINALE E I RELATIVI PASSI INTERMEDI (O FORMULE).

È dato un sistema OS161.

A) Si considerino le funzioni `thread_switch` e `thread_fork`. Quale viene utilizzata per creare un processo? Quale per creare un nuovo kernel thread? (motivare).

B) Quando viene creato un nuovo kernel thread in OS161, questo appartiene al processo che lo ha creato o può appartenere a un diverso processo? (motivare).

C) Perché la funzione `thread_exit()`, nella versione base di OS161, non può essere chiamata dopo che si è chiamata `proc_destroy` (per il processo a cui appartiene il thread)?.

D) Cosa succede se non viene chiamata la funzione `as_destroy` al termine dell’esecuzione di un processo user? Il kernel può andare in crash? (motivare).

---

## Domanda 5

**IMPORTANTE:** SE I RISULTATI SONO NUMERI, RIPORTARE PASSAGGI INTERMEDI RILEVANTI E/O FORMULE USATE. LE RISPOSTE SI/NO VANNO MOTIVATE.

Si consideri, in OS161, la realizzazione della gestione della memoria virtuale. Si risponda alle seguenti domande.

A) Si supponga di voler realizzare in `dumbvm` la gestione dei frame liberi mediante free-list, invece che con bitmap (come fatto nella soluzione proposta per il lab 2).<br>
A1) Si dica se la free list può essere una lista di frame oppure una lista di intervalli contigui di frame liberi. (motivare)<br>
A2) Qualora la lista fosse ordinata, andrebbe ordinata in base a indirizzi fisici, logici oppure in base alla dimensione di un intervallo libero?  (motivare)

B) Si supponga di voler invece realizzare una PAGE TABLE a livello di singolo processo. Viste le dimensioni ridotte della RAM fisica, si ipotizzi che una casella (entry) della PT occupi solo 2 Byte. Si ipotizzi di NON voler gestire un heap per il processo: il processo contiene quindi unicamente (come fatto in `dumbvm`) i segmenti di codice, di dati e lo stack. Si sa che:
* Il segmento 1 (codice) richiede 4 pagine, inizianti all’indirizzo `0x400000`
* Il segmento 2 (dati) richiede 3 pagine, inizianti all’indirizzo `0x500000`
* Lo stack ha dimensione 18 pagine, che terminano, anziché al massimo indirizzo logico possibile (come fatto in `dumbvm`), all’indirizzo `0x3FFFFFFF`.

B1) Si calcoli la dimensione complessiva dell’address space e, al suo interno, il numero di pagine effettivamente usate (valide).<br>
B2) Si calcoli quale sarebbe la dimensione di una page table organizzata mediante due page table standard distinte, una per i soli segmenti di codice e dato e una per lo stack.

---
