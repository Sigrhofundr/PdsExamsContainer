# Esame di Programmazione di Sistema (OS internals - Cabodi) - 20/06/2023

---

## Domanda 1

**IMPORTANTE:** Se i risultati sono numeri, riportare passaggi intermedi rilevanti e/o formule usate. Le risposte SI/NO vanno motivate.

Sia dato un sistema di memoria virtuale con paginazione a richiesta, nel quale vengono indirizzati i Byte.<br> 
Il sistema ha indirizzi su 32 bit, con pagine di 4KB, e dispone di TLB (Translation Look-aside Buffer). La tabella delle pagine ("page-table") è a un solo livello.<br> 
Non si utilizzano ulteriori strutture dati (quali tabelle di hash o inverted page table) per velocizzare gli accessi. Un TLB miss viene gestito facendo accesso alla tabella delle pagine, 
gestendo l'eventuale PF, aggiornando la TLB, e ripetendo l'accesso in memoria con TLB aggiornata.<br> 
Si sa che la memoria RAM ha tempo di accesso di 100 ns, che un Page Fault ha un costo di 2.1ms oppure 4.1ms, a seconda 
del valore del modify bit relativo alla pagina scelta come vittima. Si sono valutate tre stringhe di riferimento w1, w2 e w3, 
di lunghezza 100000 (ognuna). In w1 si osservano 10000 TLB miss e nessun PF, in w2 20000 TLB miss e 10 PF (tutti con modify bit 0), 
in w3 10000 TLB miss e 20 PF, di cui 10 con modify bit 0 e 10 con modify bit 1. Si sa inoltre che le tre stringhe rappresentano 
il comportamento del sistema in esame, assumendo che w2 e w3 siano equiprobabili e con probabilità (sia w2 che w3) doppia rispetto a w1.

Si risponda alle seguenti domande:

A) **D** - Si calcoli il numero complessivo di accessi alla TLB (compresi gli accessi ripetuti dopo un miss) eseguendo, in sequenza, le tre stringhe di riferimento.<br>
Si calcoli quindi, ESCLUDENDO I TEMPI DI PF, il tempo effettivo di accesso in RAM, dapprima per la sequenza delle tre stringhe e poi per il sistema che rappresentano (tenendo conto delle relative probabilità).<br>
**R** - Riepilogando i dati: <br>
Indirizzi 32 bit -> 4 B; DIM_Pagine 4 KB -> 4 * 1024 B = 4096 B = 2^12; (un livello => 12 bit page number - 20 offset?)<br>
Lunghezza_stringa_w1=Lunghezza_stringa_w2=Lunghezza_stringa_w3 = 100.000;<br>
TLB_miss_w1 = 10.000 ; PF_w1 = 0;<br>
TLB_miss_w2 = 20.000 ; PF_w2 = 10; (modify bit 0)<br>
TLB_miss_w3 = 10.000 ; PF_w3 = 20; (10 con mod_bit 0 e 10 con mod_bit 1)<br>
Probabilita: P(w2) = P(w3) = 2*P(w1)<br>
T_accesso_ram = 100ns; PF_mb_1 = 4.1 ms; PF_mb_0 = 2.1 ms<br>
<br>

Accessi_TLB_TOT = Lunghezza_stringa + TLB_Miss<br>
Accessi alla RAM (escludendo PF): per TLB hit: 1 accesso RAM (dato); per TLB Miss: 2 accessi RAM (Page table + dato)<br>
Tempo accesso effettivo per una stringa:<br>


Effective Access Time (EAT) nei sistemi con TLB = hit_rate_TLB * T_acc_RAM + (1-hit_rate_TLB) * 2 * T_acc_RAM<br>
dove:<br>
- hit_rate_TLB * T_acc_RAM : rappresenta il costo di quando si verifica il TLB hit; se è hit sarà necessario solo un accesso alla RAM, quindi sarà uguale a T_acc_RAM;
- (1-hit_rate_TLB) * 2 * T_acc_RAM corrisponde al costo della TLB_miss, cioè il caso in cui l'elemento non è nella TLB; <br>
la h_TLB sarà dunque data da: h_TLB = Numero_TLB_hit / Num_totale_acc_mem_logici<br>
dove:<br>
  Numero_TLB_hit = Lunghezza della stringa − Numero di TLB Miss
Stringa w1:<br>
- TLB_hit_w1 = 100.000 - 10.000 = 90.000;<br>
- h_TLB_w1 = 90.000/100.000 = 0,9;
- EAT_w1 = (0.9 * 100 * 10^-9) + (1-0.9)*2*(10^-9) = 1,1 * 10^-7 s = 110 ns;
Stringa w2: <br>
- TLB_hit_w2 = 100.000 - 20.000 = 80.000;<br>
- h_TLB_w2 = 80.000/100.000 = 0,8;
- EAT_w2 = (0.8 * 100 * 10^-9) + (1-0.8)*2*(10^-9) = 1,2 * 10^-7 s = 120 ns;
Stringa w3:<br>
visto che non consideriamo i PF sarà uguale a w1 => EAT_w1 = 110 ns;


T_acc_stringa_wi = EAT_wi * lunghezza stringa<br>
Per calcolare gli accessi TLB totali, sommiamo la lunghezza della stringa ai TLB miss (per i riaccessi dopo miss).<br>
Per il tempo di accesso RAM, consideriamo che ogni TLB hit richiede 1 accesso RAM e ogni TLB miss ne richiede 2.<br>
Il tempo medio del sistema si calcola pesando i tempi di ogni stringa con le rispettive probabilità.<br>
Accessi_TLB_TOT = Lunghezza_stringa + TLB_Miss = (sommatoria delle singole stringhe)<br>
Accessi_TLB_TOT = (100.000 + 10.000) + (100.000 + 20.000) + (100.000+ 10.000) = 340.000 accessi<br>
Stringa w1:<br>
    - T_acc_w1 = (110 * 10^-9) * 100.000 = 11 * 10^-3 s = 11 ms;<br>
Stringa w2: <br>
    - T_acc_w2 = (120 * 10^-9) * 100.000 = 12 * 10^-3 s = 12 ms;<br>
Stringa w3:<br>
    - T_acc_w3 = T_acc_w1 = 11 ms;<br>

Tempo_effettivo_accesso_in_ram_stringhe = T_w1 + T_w2 + T_w3 = (11 +12 +11) * 10^-3 = 34ms;<br>
da Probabilita: P(w2) = P(w3) = 2*P(w1)<br> mi ricavo , per sostituzione:<br>
P(w1) = p; P(w2) = 2p; P(w3) = 2p; => TOT = p+2p+2p = 5p => p = 1/5 => P(w1) = 1/5; P(w2) = P(w3) = 2/5<br>

Mi ricavo ora l'EAT medio ponderato per il sistema
EAT_sys = (P(w1) * EAT_w1) + (P(w2) * EAT_w2) + (P(w3) * EAT_w3) =
= (1/5×110 ns)+(2/5×120 ns)+(2/5×110 ns) = 22 ns + 48 ns+ 44 ns = 114 ns

B) Si considerino ora i PF. Si spieghi brevemente come va correlato il modify bit con i tempi di gestione dei PF. Si calcoli, per ognuna delle tre stringhe di riferimento e quindi per il sistema che rappresentano, il tempo effettivo di accesso in RAM, tenendo conto sia della TLB che dei PF.<br>
Innanzitutto, il MB è posto a 0 se la pagina in memoria è identica alla copia sul disco (page clean), 1 se è stata modificata in memoria (page dirty);<br>
La correlazione con PF sarà data da : <br>
1. Selezionare la pagina vittima;
2. - se PF ha MB = 0 => Non serve salvare la pagina vittima (è giù uguale su disco);
   - se PF ha MB = 1 => Salva pagina vittima su disco (write-back);
3. Carica nuova pagina dal disco;
4. Aggiorna page table e TLB : -> se MB 0 -> 2.1 ms, se MB 1 -> 4.1 ms

Tempo totale per stringa (con PF) => T_tot = T_accessi_normali + T_PF;<br>
dove<br>
T_acc_norm = (TLB_hit × t_RAM) + (TLB_miss × 2 × t_RAM);<br>
T_pf = (PF_clean × t_PF_clean) + (PF_dirty × t_PF_dirty)<br>
dove <br>
t_pf_clean = 2.1 ms; t_pf_dirty = 4.1ms <br>
T_pf_w1 = 0 (non ci sono PF)<br>
T_pf_w2 = (10 * 2.1 ms) + 0= 21 ms<br>
T_pf_w3 = (10 * 2.1 ms) + (10 * 4.1) = 21 ms + 41 ms = 62 ms<br>

Riprendendo i tempi calcolati in precedenza: <br>
T_acc_tot_w1 = 11 ms + 0 = 11 ms<br>
T_acc_tot_w2 = 12 ms + 21 ms = 33 ms<br>
T_acc_tot_w3 = 11 ms + 62 ms = 73 ms<br>

Ricalcoliamo il numeratore per il tempo medio: <br>
P_w1 * T_acc_tot_w1 = 1/5 * 11 * 10 ^-3 = 2.2 ms <br>
P_w2 * T_acc_tot_w2 = 2/5 * 33 * 10 ^-3 = 13.2 ms<br>
P_w3 * T_acc_tot_w3 = 2/5 * 73 * 10 ^-3 = 29.2 ms<br>

Nel denominatore useremo la lunghezza della stringa (100.000) perché vogliamo il tempo medio per riferimento alla memoria, non per accesso fisico.
T_medio_con_PF = (44.6 * 10^-3)/(P_w1 × 100.000 + P_w2 × 100.000 + P_w3 × 100.000) = (44.6 * 10^-3)/100.000 = 4,46 * 10^-7 = 446 nanosecondi<br>

---

## Domanda 2

**IMPORTANTE:** TUTTE LE RISPOSTE SÌ / NO DEVONO ESSERE MOTIVATE. QUANDO I RISULTATI SONO NUMERI, SONO NECESSARI IL RISULTATO FINALE E I RELATIVI PASSI INTERMEDI (O FORMULE).

Considerare un file system basato su allocazione indicizzata nel quale si utilizza per ogni file una lista di blocchi indice. 
ATTENZIONE: non si tratta di organizzazione Unix-UFS basata su INODE, ma solo di lista di blocchi indice. 
I puntatori/indici hanno una dimensione di 32 bit e i blocchi del disco hanno una dimensione di 4KB. 
Il file system risiede su una partizione del disco in cui 2TB sono riservati a **blocchi di dato e blocchi di indice**, 
a cui si aggiungono 2GB riservati a metadati (FCB, direttori, ecc., blocchi indice esclusi in quanto allocati insieme ai blocchi dato).

A) **D** - Calcolare la massima dimensione possibile per un file (si vuole la dimensione esatta del file).<br>
**R** - Dati forniti:<br>
Dim_puntatore = 32 bit = 4B; Dim_blocchi = 4 KB = 4096 B;<br>
Puntatori_per_blocco_indice = Dim_blocco / Dim_Puntatore = 1024 puntatori<br>
Puntatori_dati_per_blocco = Puntatori_per_blocco_indice - 1 = 1023 => Ogni puntatore indirizzerà un blocco<br>
Lo spazio totale - 2 TB - deve essere distribuito tra blocchi dato (x) e blocchi indice (y), quindi avremo: <br>
x + y = spazio totale /dim_blocco ;<br>
x = y * puntatore_dati_per_blocco; <br>
=> dalla seconda eq: (y*punt_dati_per_blocco) + y = spazio totale /dim blocco => (y*1023) + y =  2.199.023.255.552 B / 4096 B => y(1023 +1) = 536.870.912 => y = 536.870.912/1024 => y = 524288 blocchi indice;<br>
=> dalla prima: x + 524.288 = 536.870.912 => x = 536.346.624<br>
Riepilogando:<br>
**Blocchi dati**: 536.346.624
**Blocchi indice**: 524.288
**Dim_max_file** = Numero_blocchi_dati_massimo × Dimensione_blocco = 536.346.624 * 4096 = 2.196875772 * 10^12 TB  (inferiore allo spazio disponibile, il delta sarà dato dallo spazio occupato dai blocchi indice!)<br>
B) **D** - Dato un file binario di dimensione 8245 KB, calcolare quanti blocchi indice e blocchi di dato occupa il file. 
Calcolare anche la frammentazione interna, sia per i blocchi di dato che per quelli di indice.<br>
**R** - Convertiamo il file -> Dim_file = 8245 KB = 8245 * 1024 B = 8.442.880 B<br>
N_blocchi_dati = Dim_file /dim_blocco = 8.442.880 / 4096 = 2061.25 => 2062 <br>
Spazio_allocato_dati = n_blocchi_dati * dim_blocco = 2062 * 4096 = 8.445.952 B <br>
Frammentazione_dati = Spazio_allocato_dati - Dim_file = 8.445.952 - 8.442.880 = 3072 B <br>
Blocchi indice = blocchi_dati / puntatori_dati_per_blocco = 2062 / 1023 = 2.015 = 3<br>
Puntatori_usati = Blocchi_dati = 2062; <br>
Puntatori_allocati = blocchi_indice * 1023 = 3 * 1023 = 3069; <br>
Puntatori_sprecati = Puntatori_allocati - puntatori_usati = 3069 - 2062 = 1007; <br>
Frammentazione_indici = Puntatori_sprecati × Dimensione_puntatore = 1007 * 4 = 4028 B ; <br>

C) **D** - Si sa che il file (vedi domanda B) contiene una sequenza di numeri reali in formato double (64 bit per numero). 
Si calcoli fino a quale blocco di indice e a quale riga (casella) di questo occorre accedere per leggere i primi 512K (K va inteso come 2^10) numeri del file. 
(Verificare che la dimensione sia consistente).<br>
**R** - Numeri = 512K = 512 *2^10 = 512 *1024 = 524288 numeri;<br>
Dim_numero = 64bit = 8 B; <br>
Dim_totale = Numeri * Dim_numero = 524288 * 8 = 4.194.304 B;

Blocchi_dati_necessari = Dim_tot / dim_blocco = 4.194.304 / 4096 = 1024 blocchi<br>
Resto = Dim_totale % dim_blocco = 0<br>
Pos_ultimo_blocco = Resto = 0<br>

Blocco_indice = blocchi_dati_necessari / Puntatori_dati_per_blocco = 1024/1023 = 2<br>
Riga_nel_blocco_indice = 1024%1023 = 1<br>

---

## Domanda 3

**IMPORTANTE:** SE I RISULTATI SONO NUMERI, RIPORTARE PASSAGGI INTERMEDI RILEVANTI E/O FORMULE USATE. LE RISPOSTE SI/NO VANNO MOTIVATE.

Si consideri un contesto di paginazione a richiesta con sostituzione di pagine. Si risponda alle domande seguenti.

A) Spiegare brevemente per quale/i scopo/i possono essere usati, nella Page Table, i bit denominati:
1. valid bit (Bit di Validità)

    Scopo: Indica se la pagina logica è attualmente presente in memoria fisica (RAM).
    Funzionamento: Se 1, la pagina è in RAM e l'indirizzo nel campo frame è valido. Se 0, la pagina non è in RAM e un accesso ad essa causa un Page Fault.
    Utilizzo: Fondamentale per la gestione della paginazione a richiesta e per scatenare i Page Fault quando una pagina non è residente.

2. reference bit (Bit di Riferimento o Accesso)

   Scopo: Registra se la pagina è stata acceduta (letta o scritta) di recente dall'hardware.
   Funzionamento: Inizializzato a 0, viene impostato a 1 dall'hardware al primo accesso alla pagina.
   Utilizzo: Cruciale per gli algoritmi di sostituzione pagina basati sull'uso recente, come il Second-Chance (Clock), per identificare le pagine meno usate.

3. modify bit (Bit di Modifica o "Dirty Bit")

   Scopo: Indica se la pagina in memoria fisica è stata modificata (scritta) da quando è stata caricata.
   Funzionamento: Inizializzato a 0 al caricamento, impostato a 1 dall'hardware in caso di scrittura.
   Utilizzo: Essenziale negli algoritmi di sostituzione pagina per l'ottimizzazione: se 0, la pagina vittima non deve essere scritta su disco. Se 1, deve essere scritta (costoso) prima di essere rimpiazzata, poiché la copia in RAM è diversa da quella su disco. Utilizzato anche in algoritmi avanzati (es. Enhanced Clock) in combinazione col reference bit.
B) Si tratta di bit presenti solo nella PT o anche nella TLB? (motivare).<br>
**R** Nella TLB troviamo il valid e il modified bit, per i motivi già citati in precedenza.
C) **D** - Si vuole realizzare una Page Table a un solo livello unica per tutti i processi. È possibile?  Se no, spiegare perché. Se sì, dire quale è il costo di una conversione pagina-frame.<br>
**R** - In un contesto di sistemi operativi moderni che garantiscono l'isolamento dei processi e la sicurezza, una tale configurazione non è possibile. La fattibilità dipende fortemente dallo scopo e dall'architettura hardware specifica.<br>
Le ragioni principali sono:
- Isolamento dei processi e protezione: Ogni processo in un sistema operativo moderno ha il proprio spazio di indirizzamento logico virtuale. 
Una PT unica per tutti i processi violerebbe completamente questo isolamento. Ogni processo potrebbe accedere (e potenzialmente modificare) 
la memoria di qualsiasi altro processo, creando gravi problemi di sicurezza, stabilità e privacy. I dati e il codice dei processi non sarebbero protetti.
- Gestione della memoria: Ogni processo ha la propria visione della memoria, con le proprie pagine mappate a frame fisici. Una PT unica implicherebbe che tutti i 
processi condividano lo stesso identico spazio di indirizzamento virtuale e le stesse mappature, cosa che non è compatibile con la gestione di più processi concorrenti e 
indipendenti. Le pagine di un processo potrebbero essere sovrascritte o confuse con quelle di un altro.
- Ambito degli indirizzi virtuali: In un sistema con più processi, indirizzi virtuali identici in processi diversi devono 
mappare a indirizzi fisici diversi. Una PT unica non permetterebbe questa distinzione in modo efficiente e sicuro.

Costo di una conversione pagina-frame (se fosse possibile):

Se, ipoteticamente e in un contesto non realistico di sistema moderno, una tale configurazione fosse implementabile (ad esempio in un sistema monoprocesso o con forte cooperazione e senza requisiti di sicurezza):

Il costo di una conversione pagina-frame (senza considerare la TLB) sarebbe di un singolo accesso alla RAM. 
Questo perché la Page Table a un solo livello risiede in RAM e ogni ricerca di traduzione richiederebbe di accedere all'entrata appropriata della Page Table per ottenere il numero di frame fisico.

---

## Domanda 4

**IMPORTANTE:** TUTTE LE RISPOSTE SÌ / NO DEVONO ESSERE MOTIVATE. QUANDO I RISULTATI SONO NUMERI, SONO NECESSARI IL RISULTATO FINALE E I RELATIVI PASSI INTERMEDI (O FORMULE).

È dato un sistema OS161.

A) Si considerino le funzioni `thread_switch` e `thread_fork`. Quale viene utilizzata per creare un processo? Quale per creare un nuovo kernel thread? (motivare).

B) Quando viene creato un nuovo kernel thread in OS161, questo appartiene al processo che lo ha creato o può appartenere a un diverso processo? (motivare).

C) Perché la funzione `thread_exit()`, nella versione base di OS161, non può essere chiamata dopo che si è chiamata `proc_destroy` (per il processo a cui appartiene il thread)?.

D) Cosa succede se non viene chiamata la funzione `as_destroy` al termine dell’esecuzione di un processo user? Il kernel può andare in crash? (motivare).

---

## Domanda 5

**IMPORTANTE:** SE I RISULTATI SONO NUMERI, RIPORTARE PASSAGGI INTERMEDI RILEVANTI E/O FORMULE USATE. LE RISPOSTE SI/NO VANNO MOTIVATE.

Si consideri, in OS161, la realizzazione della gestione della memoria virtuale. Si risponda alle seguenti domande.

A) Si supponga di voler realizzare in `dumbvm` la gestione dei frame liberi mediante free-list, invece che con bitmap (come fatto nella soluzione proposta per il lab 2).<br>
A1) Si dica se la free list può essere una lista di frame oppure una lista di intervalli contigui di frame liberi. (motivare)<br>
A2) Qualora la lista fosse ordinata, andrebbe ordinata in base a indirizzi fisici, logici oppure in base alla dimensione di un intervallo libero?  (motivare)

B) Si supponga di voler invece realizzare una PAGE TABLE a livello di singolo processo. Viste le dimensioni ridotte della RAM fisica, si ipotizzi che una casella (entry) della PT occupi solo 2 Byte. Si ipotizzi di NON voler gestire un heap per il processo: il processo contiene quindi unicamente (come fatto in `dumbvm`) i segmenti di codice, di dati e lo stack. Si sa che:
* Il segmento 1 (codice) richiede 4 pagine, inizianti all’indirizzo `0x400000`
* Il segmento 2 (dati) richiede 3 pagine, inizianti all’indirizzo `0x500000`
* Lo stack ha dimensione 18 pagine, che terminano, anziché al massimo indirizzo logico possibile (come fatto in `dumbvm`), all’indirizzo `0x3FFFFFFF`.

B1) Si calcoli la dimensione complessiva dell’address space e, al suo interno, il numero di pagine effettivamente usate (valide).<br>
B2) Si calcoli quale sarebbe la dimensione di una page table organizzata mediante due page table standard distinte, una per i soli segmenti di codice e dato e una per lo stack.

---
