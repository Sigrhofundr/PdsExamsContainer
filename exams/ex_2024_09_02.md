<h1>Esame del 09 Settembre 2024</h1>

<ol><!-- Numero domanda, settore principale-->
<li>
<ol style="list-style-type: decimal"><!-- Elenco numerato interno -->
<li><b>D</b> - In un sistema con tabella delle pagine invertita, una singola entry della tabella delle pagine può essere
condivisa da più pagine virtuali di processi diversi senza causare un conflitto nella traduzione degli indirizzi? (SÌ/NO, Spiega/motiva brevemente)
<b>R</b> - Dipende, nella forma di base della IPT, nel quale ogni entry detiene il numero di pagina e il pid, non sarebbe possibile,
in quanto un dato frame può appartenere a un solo processo. Questo sarebbe un problema per le pagine/librerie condivise.
Dato che solitamente le IPT sono integrate con le tabelle hash, la maggior parte delle IPT contengono anche un puntatore, utilizzato per
le collisioni hash di catene/liste. La tabella delle pagine di tipo hash standard non sarebbe abbastanza per condividere un
IPT entry a seconda dei processi diversi (a causa di come la funzione di hash funziona, le entries non sarebbero nello
stessa lista di collisioni dell'hash). Può essere fatto grazie a delle soluzioni software sofisticate, nel quale
si usa il puntatore IPT, nel caso di frame condivisi, per una lista di pagine che condividono il frame.
</li>
<li><b>D</b> - In un sistema che utilizza la sostituzione di pagina locale, un processo con un tasso molto elevato di 
page fault può comunque causare una riduzione della memoria fisica disponibile ad altri processi? (SÌ/NO, Spiega/motiva brevemente)
<b>R</b> - NO, nella sostituzione locale pura ogni processo ha un resident set fisso e può sostituire solo le 
proprie pagine, quindi non può direttamente sottrarre memoria fisica ad altri processi.
</li>
<li><b>D</b> - In un sistema di memoria virtuale con un grado di multiprogrammazione fisso, il thrashing può comunque 
verificarsi se la somma dei working set di tutti i processi è inferiore alla memoria fisica disponibile ma l'algoritmo 
di sostituzione delle pagine non è ottimizzato? (SÌ/NO, Spiega/motiva brevemente)
<b>R</b> - Sì, il trashing accade quando l'algoritmo di sostituzione di pagina non predice correttamente o gestisce 
correttamente il working set dei processi, portando a frequenti e non necessarie sostituzione di pagina. Questa inefficienza
può causare ai processi la rimozione ripetuta di pagine di cui presto avranno bisogno nuovamente, risultando in un eccessivo nu,ero
di page fault e trashing, nonostante la memoria fisica sia sufficiente.
</li>
<li>Considera un sistema a 64 bit con uno spazio di indirizzamento virtuale di 2^48 byte, una dimensione di 
pagina di 4 KB e 16 GB di memoria fisica. Supponiamo che il sistema utilizzi una tabella delle pagine invertita. 
Calcola e spiega quanto segue:
<ol style="list-style-type: upper-alpha">
    <li><b>D</b> - Il numero di bit richiesti per il numero di frame fisico.<br>
<b>R</b> - Intanto come dati abbiamo: Sistema 64 bit, spazio indirizzamento 2^48 (281TB), DIM Pagina 4 KB = 2^12, e 16 GB = 2^34 memoria
Il numero di frame fisici, RAM / dim pagina = 2^34 / 2^12 = 2^22 =4194304 circa 4M, ma da questo indice ci ricaviamo che il numero di bit richiesti
per il physical frame number è 22.
    </li>
    <li><b>D</b> - Il numero totale di entry nella tabella delle pagine invertita.<br>
<b>R</b> - Sarà uguale al numero dei frame fisici per definizione: 2^22
</li>
    <li><b>D</b> - L'indirizzo virtuale dato a un processo è 0x00007FFFFFFFF000. Determina l'indirizzo fisico 
se questo indirizzo virtuale è mappato al 1.024° frame fisico. Mostra tutti i passaggi, 
incluso il calcolo del numero di pagina e dell'offset.<br>
<b>R</b> - Riportiamo i dati:
<ul>
<li> Virtual Address: 0x00007FFFFFFFF000; Page size: 2^12, ricordiamoci anche che i bit necessari li possiamo facendo la funzione inversa 
rispetto al dato che ci viene dato, quindi log in base 2 di 4096 = 12;
</li>
<li>l'offset, sarà dunque di 12 bit (gli ultimi 12, i 3 0 finali esadecimali)</li>
<li>il numero di pagina virtuale sarà dato allora da 0x00007FFFFFFFF</li>
<li>Nella fase successiva, il 1024esimo frame corrisponderà al numero di frame fisico di 1024, in esadecimale 0x00000400 </li>
<li>Per ottenere l'indirizzo fisico, combiniamo il physical frame con l'offset</li>
<li>Indirizzo_fisico = (frame << 12) | offset => (0x00000400 << 12) | 0x000 => 0x000400000 <!--Nella soluzione caricata del prof c'è uno zero extra--></li>
</ul>
</li>
</ol>
</ol><!-- FINE Elenco numerato interno -->
</li>
<li>Considera un file system che utilizza l'allocazione concatenata (<b>linked allocation</b>) per l'archiviazione dei file. 
Il disco è diviso in blocchi di 4 KB ciascuno. Ogni blocco contiene un puntatore al blocco successivo, che occupa 4 byte del blocco. 
Un file richiede 5 MB di spazio di archiviazione.
<ol style="list-style-type: upper-alpha">
<li><b>D</b> - Calcola il numero di blocchi disco richiesti per memorizzare l'intero file, incluso lo spazio necessario per i puntatori.
<b>R</b> - 
</li>
<li><b>D</b> - Se i puntatori fossero ridotti a 2 byte (assumendo una capacità del disco minore), ricalcola il numero di blocchi richiesti. 
Questa modifica renderebbe più efficiente la memorizzazione del file in termini di utilizzo dei blocchi?
<b>R</b> - 
</li>
<li><b>D</b> - Confronta l'overhead introdotto dai puntatori in entrambi i casi come percentuale dello storage totale utilizzato.
<b>R</b> - 
</li>
</ol>
</li>
<li>
<ol style="list-style-type: upper-alpha">
<li><b>D</b> - In un sistema con più dispositivi I/O e una singola CPU, le operazioni di I/O possono avvenire in 
parallelo se la CPU è impegnata nell'esecuzione di un processo?
<b>R</b> - 
</li>
<li><b>D</b> - In un sistema con memoria virtuale a paginazione su richiesta e DMA, un page fault può verificarsi 
durante un trasferimento DMA, causando il fallimento del trasferimento se non vengono prese le dovute precauzioni?
<b>R</b> - 
</li>
<li><b>D</b> - C. In un sistema che utilizza I/O basato su interrupt, è possibile che un interrupt venga perso 
se il controller degli interrupt è occupato a elaborare un altro interrupt e il dispositivo che ha attivato il secondo 
interrupt non supporta la coda degli interrupt?
<b>R</b> - 
</li>
<li>Considera un Hard Disk Drive (HDD) con le seguenti specifiche:
        <ul>
            <li>Dimensione del settore: 512 Byte</li>
            <li>Numero di tracce per superficie: 5.000</li>
            <li>Numero di settori per traccia: 300</li>
            <li>Numero di piatti a doppia faccia: 6</li>
            <li>Velocità di rotazione del piatto: 7.200 rpm (giri al minuto)</li>
        </ul>
<ol style="list-style-type: decimal">
<li><b>D</b> - Calcola la massima velocità di trasferimento dati possibile in megabyte al secondo (MB/s), 
assumendo che una traccia di dati possa essere trasferita per rivoluzione.
<b>R</b> - 
</li>
<li><b>D</b> -Se il disco subisce un crash della testina su un piatto, come influisce questo sulla capacità totale e 
sulla disponibilità dei dati, assumendo che non siano presenti meccanismi RAID o di backup?
<b>R</b> - 
</li>
<li><b>D</b> -Se il disco ha un tempo di seek medio di 4 ms e deve leggere un file di 1 GB diviso su 200 tracce non 
contigue, calcola il tempo totale richiesto per leggere il file. Includi il tempo di seek, la latenza rotazionale e il 
trasferimento dati. Supponi che la latenza rotazionale media sia di 4,165 ms e che una traccia possa essere letta per rivoluzione.
<b>R</b> - 
</li>
</ol>
</li>
</ol>
</li>
</ol>