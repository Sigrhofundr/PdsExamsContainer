<h1>Esame del 09 Settembre 2024</h1>

<ol><!-- Numero domanda, settore principale-->
<li>
<ol style="list-style-type: decimal"><!-- Elenco numerato interno -->
<li><b>D</b> - In un sistema con tabella delle pagine invertita, una singola entry della tabella delle pagine può essere
condivisa da più pagine virtuali di processi diversi senza causare un conflitto nella traduzione degli indirizzi? (SÌ/NO, Spiega/motiva brevemente)<br>
<b>R</b> - Dipende, nella forma di base della IPT, nel quale ogni entry detiene il numero di pagina e il pid, non sarebbe possibile,
in quanto un dato frame può appartenere a un solo processo. Questo sarebbe un problema per le pagine/librerie condivise.
Dato che solitamente le IPT sono integrate con le tabelle hash, la maggior parte delle IPT contengono anche un puntatore, utilizzato per
le collisioni hash di catene/liste. La tabella delle pagine di tipo hash standard non sarebbe abbastanza per condividere un
IPT entry a seconda dei processi diversi (a causa di come la funzione di hash funziona, le entries non sarebbero nello
stessa lista di collisioni dell'hash). Può essere fatto grazie a delle soluzioni software sofisticate, nel quale
si usa il puntatore IPT, nel caso di frame condivisi, per una lista di pagine che condividono il frame.
</li>
<li><b>D</b> - In un sistema che utilizza la sostituzione di pagina locale, un processo con un tasso molto elevato di 
page fault può comunque causare una riduzione della memoria fisica disponibile ad altri processi? (SÌ/NO, Spiega/motiva brevemente)<br>
<b>R</b> - NO, nella sostituzione locale pura ogni processo ha un resident set fisso e può sostituire solo le 
proprie pagine, quindi non può direttamente sottrarre memoria fisica ad altri processi.
</li>
<li><b>D</b> - In un sistema di memoria virtuale con un grado di multiprogrammazione fisso, il thrashing può comunque 
verificarsi se la somma dei working set di tutti i processi è inferiore alla memoria fisica disponibile ma l'algoritmo 
di sostituzione delle pagine non è ottimizzato? (SÌ/NO, Spiega/motiva brevemente)<br>
<b>R</b> - Sì, il trashing accade quando l'algoritmo di sostituzione di pagina non predice correttamente o gestisce 
correttamente il working set dei processi, portando a frequenti e non necessarie sostituzione di pagina. Questa inefficienza
può causare ai processi la rimozione ripetuta di pagine di cui presto avranno bisogno nuovamente, risultando in un eccessivo nu,ero
di page fault e trashing, nonostante la memoria fisica sia sufficiente.
</li>
<li>Considera un sistema a 64 bit con uno spazio di indirizzamento virtuale di 2^48 byte, una dimensione di 
pagina di 4 KB e 16 GB di memoria fisica. Supponiamo che il sistema utilizzi una tabella delle pagine invertita. 
Calcola e spiega quanto segue:
<ol style="list-style-type: upper-alpha">
    <li><b>D</b> - Il numero di bit richiesti per il numero di frame fisico.<br>
<b>R</b> - Intanto come dati abbiamo: Sistema 64 bit, spazio indirizzamento 2^48 (281TB), DIM Pagina 4 KB = 2^12, e 16 GB = 2^34 memoria
Il numero di frame fisici, RAM / dim pagina = 2^34 / 2^12 = 2^22 =4194304 circa 4M, ma da questo indice ci ricaviamo che il numero di bit richiesti
per il physical frame number è 22.
    </li>
    <li><b>D</b> - Il numero totale di entry nella tabella delle pagine invertita.<br>
<b>R</b> - Sarà uguale al numero dei frame fisici per definizione: 2^22
</li>
    <li><b>D</b> - L'indirizzo virtuale dato a un processo è 0x00007FFFFFFFF000. Determina l'indirizzo fisico 
se questo indirizzo virtuale è mappato al 1.024° frame fisico. Mostra tutti i passaggi, 
incluso il calcolo del numero di pagina e dell'offset.<br>
<b>R</b> - Riportiamo i dati:
<ul>
<li> Virtual Address: 0x00007FFFFFFFF000; Page size: 2^12, ricordiamoci anche che i bit necessari li possiamo facendo la funzione inversa 
rispetto al dato che ci viene dato, quindi log in base 2 di 4096 = 12;
</li>
<li>l'offset, sarà dunque di 12 bit (gli ultimi 12, i 3 0 finali esadecimali)</li>
<li>il numero di pagina virtuale sarà dato allora da 0x00007FFFFFFFF</li>
<li>Nella fase successiva, il 1024esimo frame corrisponderà al numero di frame fisico di 1024, in esadecimale 0x00000400 </li>
<li>Per ottenere l'indirizzo fisico, combiniamo il physical frame con l'offset</li>
<li>Indirizzo_fisico = (frame << 12) | offset => (0x00000400 << 12) | 0x000 => 0x000400000 <!--Nella soluzione caricata del prof c'è uno zero extra--></li>
</ul>
</li>
</ol>
</ol><!-- FINE Elenco numerato interno -->
</li>
<li>Considera un file system che utilizza l'allocazione concatenata (<b>linked allocation</b>) per l'archiviazione dei file. 
Il disco è diviso in blocchi di 4 KB ciascuno. Ogni blocco contiene un puntatore al blocco successivo, che occupa 4 byte del blocco. 
Un file richiede 5 MB di spazio di archiviazione.
<ol style="list-style-type: upper-alpha">
<li><b>D</b> - Calcola il numero di blocchi disco richiesti per memorizzare l'intero file, incluso lo spazio necessario per i puntatori.
<br><b>R</b> - Ci dobbiamo ricavare il numero preciso di bytes -> Dim file = 5 MB = 5 * 1024 * 1024 = 5.242.880; ogni blocco = 4KB = 4096 B<br> <!-- Nella soluzione del prof c'è un *1024 in più-->
- Però dato che all'inizio del blocco vi sono 4 B di puntatori, il blocco = 4096-4 = 4092<br>
- N_Blocchi_disco = DIM_file/DIM_Singolo_blocco = 5242880/4092 =  1281.25 => 1282 blocchi (per puntatori a 4 byte)
</li>
<li><b>D</b> - Se i puntatori fossero ridotti a 2 byte (assumendo una capacità del disco minore), ricalcola il numero di blocchi richiesti. 
Questa modifica renderebbe più efficiente la memorizzazione del file in termini di utilizzo dei blocchi?<br>
<b>R</b> - Ricalcoliamo: Dim_blocco = 4096 -2 = 4094 B => N_Blocchi_disco = DIM_file/DIM_Singolo_blocco = 5242880/4094 = 1280.62 => 1281 blocchi <br>
- Quindi si risparmia un blocco
</li>
<li><b>D</b> - Confronta l'overhead introdotto dai puntatori in entrambi i casi come percentuale dello storage totale utilizzato.<br>
<b>R</b> - Nel I caso => Overehead_I = 4* 1282 = 5128 bytes; Nel II Caso => Overhead_II = 2 * 1281 = 2562 Bytes; <br>
- ricaviamo le percentuali: Overhead_I = 5128/5242880 * 100 = 0.0978%; Overhead_II = 2562/5242880 * 100 = 0.0488 %; <br>
quindi l'overhead è quasi dimezzato quando i usa un puntatore a 2B
</li>
</ol>
</li>
<li>
<ol style="list-style-type: upper-alpha">
<li><b>D</b> - In un sistema con più dispositivi I/O e una singola CPU, le operazioni di I/O possono avvenire in 
parallelo se la CPU è impegnata nell'esecuzione di un processo?<br>
<b>R</b> - Sì. Le operazioni I/O possono essere gestite da controllori I/O dedicati (ad esempio DMA), permettendo loro
di procedere indipendentemente dalla CPU, la quale può continuare a eseguire processi mentre le operazioni I/O procedono;
</li>
<li><b>D</b> - In un sistema con memoria virtuale a paginazione su richiesta e DMA, un page fault può verificarsi 
durante un trasferimento DMA, causando il fallimento del trasferimento se non vengono prese le dovute precauzioni?<br>
<b>R</b> - Certo. Il page fault non è causato dal trasferimento del DMA, dato che il DMA gestisce solo indirizzi fisici, e 
quindi fisicamente contigui in memoria, ma una page fault può essere innescata da un codice (dello stesso o di un altro 
processo) eseguito in parallelo. Se ciò accade, le pagine coinvolte nel DMA non dovrebbero essere selezionate come vittime 
per la sostituzione. Il sistema operativo dovrebbe pertanto o bloccare le pagine in memoria durante il trasferimento del DMA 
oppure gestire i page fault in maniera tale da non impedire il corretto funzionamento del processo DMA;
</li>
<li><b>D</b> - C. In un sistema che utilizza I/O basato su interrupt, è possibile che un interrupt venga perso 
se il controller degli interrupt è occupato a elaborare un altro interrupt e il dispositivo che ha attivato il secondo 
interrupt non supporta la coda degli interrupt?<br>
<b>R</b> - Sì. Se il controller degli interrupt è occupato nella gestione di un altro interrupt, e il dispositivo che ha 
innescato il secondo interrupt non supporta l'accodamento dell'interrupt, quest'ultimo andrà perso. Questo accade perché il
 controller dell'interrupt potrebbe non essere capace di registrare i nuovi inputs mentre gestisce quello corrente, e senza 
l'accodamento, il dispositivo non può gestire la richiesta dell'interrupt fino a quando il controllore è pronto;
</li>
<li>Considera un Hard Disk Drive (HDD) con le seguenti specifiche:
        <ul>
            <li>Dimensione del settore: 512 Byte</li>
            <li>Numero di tracce per superficie: 5.000</li>
            <li>Numero di settori per traccia: 300</li>
            <li>Numero di piatti a doppia faccia: 6</li>
            <li>Velocità di rotazione del piatto: 7.200 rpm (giri al minuto)</li>
        </ul>
<ol style="list-style-type: decimal">
<li><b>D</b> - Calcola la massima velocità di trasferimento dati possibile in megabyte al secondo (MB/s), 
assumendo che una traccia di dati possa essere trasferita per rivoluzione.<br>
<b>R</b> - Premettendo che stiamo assumendo che i dati non vengano letti/scritti in parallelo, calcoliamo: 
<ul>
<li>Rivoluzioni per secondo = RPM / 60 = 7200/60 = 120 giri al secondo; </li>
<li>Dati per traccia = num settori per traccia * dimensione del settore = 300 * 512 = 153600 B = 153,6 KB</li>
<li>Il throughput massimo = Dati per traccia * rivoluzioni per secondo = 0,1536 MB * 120 = 18,432 MB/s</li>
</ul>
</li>
<li><b>D</b> -Se il disco subisce un crash della testina su un piatto, come influisce questo sulla capacità totale e 
sulla disponibilità dei dati, assumendo che non siano presenti meccanismi RAID o di backup?<br>
<b>R</b> - Tenendo conto che 6 platter double-sided = 12 superfici totali;  Capacità per superficie = Tracks × Sectors per track × Sector size
= 5000 * 300 * 512 B = 768MB => Capacità complessiva 768MB * 12 = 9,216GB<br>
Se il crash coinvolge un platter completo (entrambi i lati):
Superfici perse: 2 (entrambi i lati del platter)
Capacità persa: 2 × Capacità per superficie
Percentuale di perdita: 2/12 = 16.67% della capacità totale => in spazio (meno la %) circa 7,67 GB rimanenti. <br>
I dati sul piatto, se non esiste una copia del backup, saranno irrimediabilmente persi
</li>
<li><b>NOTA: VERSIONE CORRETTA</b> - <b>D</b> - Se il disco ha un tempo di seek medio di 4 ms e deve leggere un file di 350MB diviso su 200 tracce non 
contigue, calcola il tempo totale richiesto per leggere il file. Includi il tempo di seek, la latenza rotazionale e il 
trasferimento dati. Supponi che la latenza rotazionale media sia di 4,165 ms e che una traccia possa essere letta per rivoluzione.<br>
<b>R</b> - Elenchiamo tutti i dati:
<ul>
<li>Dimensione del file = 350 MB = 350 * 1024 * 1024 = 367.001.600 Bytes</li>
<li>Data per track: dimensione_file / numero_tracce = 350 MB / 200 = 1.75 MB per traccia</li>
<li>Transfer_rate_per_track = Capacity_per_track / Time_per_revolution = 153600/ 8,33 ms = 18432 MB/s</li>
<li>Total_Transfer_time_ = Data_per_track / (Transfer_rate_per_track* Number_of_tracks) = 1.75 MB / (18432 MB/s*200) = 18,99 sec </li>
<li>Total_Seek_Time = Number_of_tracks × Average_seek_time = 200 * 4 ms = 0,8 sec</li>
<li>Total_Rotational_Latency = Number_of_tracks × Average_rotational_latency = 200 * 4165 ms = 0,833 sec</li>
<li>Transfer_time_per_track = 60 / RPM (tempo per una rivoluzione completa) = 8,3 ms </li>
<li>Total_Time = Total_Seek_Time + Total_Rotational_Latency + Total_Transfer_Time = 18,99 + 0,833 + 0,8 = 20,62 sec</li>

</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>