# Esame di Programmazione di Sistema - Cabodi OS - 07 Luglio 2023
---

## Domanda 1: Gestione della Memoria e Algoritmo di Sostituzione delle Pagine

Considera la seguente stringa di riferimenti di memoria, per un dato processo. Per ogni riferimento (indirizzamento a Byte, con indirizzi espressi in codice esadecimale) 
è riportata anche l'operazione di lettura(R)/scrittura(W): R 33FB, R 1B64, W 30D3, W 237E, R 0AC8, W 23D7, R 174A, R 0965, W 32A0, R 1BB0, W 09E5, R 3380, R 2A94, R 11B8. 
Assumi che gli indirizzi fisici e logici siano a 16 bit, la dimensione della pagina sia 2 KByte e 70FF sia l'indirizzo massimo utilizzabile dal programma (il limite superiore dello spazio di indirizzamento).<br>
A) **D** - Calcola la dimensione dello spazio di indirizzamento (espressa come numero di pagine) e la frammentazione interna.<br>
**R** - Riepilogando: <br>
Indirizzi = 16 bit => 2 B; Dim_Pagina = 2KB = 2 * 1024 B = 2048 B = 2^11; Ind Max Programma = 70FF_ex = 28927_dec < 2^15 <br>
DIM_SPAZIO = IND_MAX + 1 => 70FF +1 = 7100 => 28928 B = 28KB + 256B 
#_pagine = arr_per_eccesso(Dimensione_spazio/Dim_Pagina) = arr_ex(28928/2048) = 14,125 => 15
Spazio utilizzato = DIM_SPAZIO
Spazio allocato = Pagine_necessarie * DIM_PAG = 15 * 2048= 30720
Frammentazione interna = Spazio allocato - utilizzato = 30720 - 28928 = 1792 B
B) **D** - Calcola la stringa dei riferimenti di pagina.<br>
**R** - Intanto:<br>
per ottenere il numero di pagina, convertiamo l'indirizzo da esadecimale a decimale, quindi dividiamo per la dimensione della pagina (2048) (si potrebbe usare anche il metodo dello shift):<br>
6 3 6 4 1 4 2 1 6 3 1 6 5 2<br>
C) **D** - Simula un algoritmo di sostituzione delle pagine Second-Chance, con 3 frame disponibili. Rappresenta il set residente (frame fisici contenenti pagine logiche) dopo ogni riferimento 
di memoria. Indica esplicitamente, per ogni frame allocato, il numero di pagina e il bit di riferimento (usa la notazione p,r o pr). 
Indica anche i page fault. Assumi che il bit di riferimento di una pagina sia inizializzato a 0 dopo un page fault.<br>
<table>
  <thead>
    <tr>
      <th style="background-color: #f2f2f2;">Time</th>
      <th style="background-color: #f2f2f2;">0</th>
      <th style="background-color: #f2f2f2;">1</th>
      <th style="background-color: #f2f2f2;">2</th>
      <th style="background-color: #f2f2f2;">3</th>
      <th style="background-color: #f2f2f2;">4</th>
      <th style="background-color: #f2f2f2;">5</th>
      <th style="background-color: #f2f2f2;">6</th>
      <th style="background-color: #f2f2f2;">7</th>
      <th style="background-color: #f2f2f2;">8</th>
      <th style="background-color: #f2f2f2;">9</th>
      <th style="background-color: #f2f2f2;">10</th>
      <th style="background-color: #f2f2f2;">11</th>
      <th style="background-color: #f2f2f2;">12</th>
      <th style="background-color: #f2f2f2;">13</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>References</td>
      <td>6</td>
      <td>3</td>
      <td>6</td>
      <td>4</td>
      <td>1</td>
      <td>4</td>
      <td>2</td>
      <td>1</td>
      <td>6</td>
      <td>3</td>
      <td>1</td>
      <td>6</td>
      <td>5</td>
      <td>2</td>
    </tr>
    <tr>
      <td>Resident Set</td>
      <td>6₀</td>
      <td>6₀</td>
      <td>6₁</td>
      <td style="background-color: #DDDDDD;">6₁</td>
      <td>6₀</td>
      <td>6₀</td>
      <td>2₀</td>
      <td>2₀</td>
      <td style="background-color: #DDDDDD;">2₀</td>
      <td>3₀</td>
      <td>3₀</td>
      <td>3₀</td>
      <td>5₀</td>
      <td>5₀</td>
    </tr>
    <tr>
      <td></td>
      <td>3₀</td>
      <td>3₀</td>
      <td>3₀</td>
      <td>3₀</td>
      <td>1₀</td>
      <td>1₀</td>
      <td style="background-color: #DDDDDD;">1₀</td>
      <td style="background-color: #DDDDDD;">1₁</td>
      <td>1₀</td>
      <td style="background-color: #DDDDDD;">1₀</td>
      <td style="background-color: #DDDDDD;">1₁</td>
      <td style="background-color: #DDDDDD;">1₁</td>
      <td style="background-color: #DDDDDD;">1₀</td>
      <td>2₀</td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
      <td></td>
      <td>4₀</td>
      <td style="background-color: #DDDDDD;">4₀</td>
      <td style="background-color: #DDDDDD;">4₁</td>
      <td>4₀</td>
      <td>4₀</td>
      <td>6₀</td>
      <td>6₀</td>
      <td>6₀</td>
      <td>6₁</td>
      <td>6₀</td>
      <td style="background-color: #DDDDDD;">6₀</td>
    </tr>
    <tr>
      <td>Page Faults</td>
      <td>*</td>
      <td>*</td>
      <td></td>
      <td>*</td>
      <td>*</td>
      <td></td>
      <td>*</td>
      <td></td>
      <td>*</td>
      <td>*</td>
      <td></td>
      <td></td>
      <td>*</td>
      <td>*</td>
    </tr>
  </tbody>
</table>

---

## Domanda 2: Hard Disk Drive (HDD)

Considera un Hard Disk Drive (HDD) con tecnologia e geometria standard. Il disco ha:
* dimensione del settore di 512 Byte,
* 2048 tracce per superficie,
* 50 settori per traccia,
* 5 piatti a doppia faccia,
* tempo medio di seek di 10 msec.

A) Qual è la capacità di una traccia (in Byte)? Qual è la capacità di ogni superficie? Qual è la capacità del disco? Quanti cilindri ha il disco?
B) Il metodo di indirizzamento del disco CHR (Cilindro-Testina-Settore) consente a un blocco disco di estendersi su più settori di una data traccia (identificata da una coppia cilindro, testina), ma non su tracce diverse. I seguenti sono formati di blocco validi: 256 B, 2048 B, 51200 B? (Motivare le risposte)
C) Se i piatti del disco ruotano a 5400 rpm (rivoluzioni al minuto), qual è il ritardo massimo di rotazione? Qual è il ritardo medio di rotazione? Se una traccia di dati può essere trasferita per rivoluzione, qual è il tasso di trasferimento (espresso in bit/secondo)? Quale sarebbe il tasso di trasferimento se un intero cilindro di dati potesse essere trasferito per rivoluzione?

---

## Domanda 3: Organizzazione e Formati di File

Un'applicazione ha bisogno di organizzare un file con un'intestazione e più sezioni. L'intestazione include, tra gli altri dati, offset e dimensioni di tutte le sezioni nel file.
A) per ciascuna delle domande seguenti, rispondi sì/no e motiva la risposta:
1.  L'applicazione può assumere che l'intestazione, così come ogni sezione, sia allineata con (memorizzata a partire da) i confini dei blocchi disco nel file system?
2.  L'applicazione può organizzare i dati in più file (invece di un singolo file): un file per l'intestazione e uno per ogni sezione? (Se NO, motivare, se SÌ, motivare e spiegare come gli offset delle sezioni nell'intestazione dovrebbero essere rappresentati, codificati o modificati)

Un file di testo viene copiato su tre diversi file system, i cui formati di file sono, rispettivamente:
* allocazione contigua (per multipli di un blocco disco)
* allocazione concatenata (senza FAT)
* Inode

B) Rispondi alla seguente domanda e motiva la risposta:
1.  La dimensione di un blocco disco è la stessa su tutti e tre i file system. Possiamo assumere che la frammentazione interna sarà la stessa su tutti i file system?

Un file system contiene tre file di testo `a.txt`, `b.txt` e `c.txt`. Un'applicazione di archiviazione/compressione file (come ad esempio gzip, tar, 7z, rar, etc.) memorizza il (contenuto di) i tre file di testo all'interno di un singolo file archivio (e.g. `abc.zip`). Per ciascuna delle domande seguenti, rispondi sì/no e motiva la risposta:
C)
1.  I tre file di testo possono condividere lo stesso blocco disco, il che significa che il file system li sta memorizzando (almeno parzialmente) all'interno dello stesso blocco disco?
2.  È possibile, per il contenuto dei tre file di testo, replicato e/o compresso nel file archivio, condividere (almeno parzialmente) lo stesso blocco disco (so to be stored within the same disk block)?

---

## Domanda 4: Framework del File System di OS161 (LAB5)

Viene dato un sistema OS161. Considera il framework del file system utilizzato nel LAB5, parzialmente rappresentato dai seguenti estratti di codice:

```c
// Code excerpts from files proc.h and file_syscalls.c

struct proc {
    // ...
    #if OPT_FILE
    /* per-process open file table */
    struct openfile *fileTable[OPEN_MAX];
    #endif
};

/* system open file table */
struct openfile {
    struct vnode *vn;
    off_t offset;
    unsigned int countRef;
};
struct openfile systemFileTable[SYSTEM_OPEN_MAX];
```

A) Perché `systemFileTable` è un array di `struct openfile`, mentre `fileTable` è un array di puntatori a `struct openfile`?
B) Il campo `countRef` è ridondante, considerando che il `vnode` puntato dal campo `vn` ha il proprio conteggio di riferimenti?
C) Nel caso in cui sia necessario supportare il blocco dei file (file locking), cosa dovremmo scegliere tra uno spinlock e un lock, e dove dovrebbe essere posizionato (o dove dovrebbero essere posizionati, se multipli): in `systemFileTable`, in `fileTable`, o altrove?
D) Qual è il possibile ruolo delle funzioni `copyin` e `copyout` nell'implementazione delle chiamate di sistema `sys_read` e `sys_write`?

---

## Domanda 5: Implementazioni di `spinlock_acquire` in OS161

Considera, in OS161, le due possibili implementazioni di `spinlock_acquire` mostrate di seguito:

```c
void spinlock_acquire(struct spinlock *splk) {
 //
 while (1) {
    if (spinlock_data_get(&splk->splk_lock) != 0) {
    }
    continue;
    if (spinlock_data_testandset(&splk->splk_lock) != 0) {
    continue;
    break;
    }
 }
 //
}

void spinlock_acquire2 (struct spinlock *splk) {
 //
 while (1) {
    while (spinlock_data_get(&splk->splk_lock) != 0);
    if (spinlock_data_testandset(&splk->splk_lock) == 0) {
    continue;
    }
 }
 //
}
```

A) Perché `spinlock_acquire` utilizza sia `spinlock_data_get` che `spinlock_data_testandset`, invece di chiamarne solo una?
B) `spinlock_acquire2` è equivalente a `spinlock_acquire`? Se Sì, motiva, se No, motiva e, se possibile, modificala per renderla equivalente
