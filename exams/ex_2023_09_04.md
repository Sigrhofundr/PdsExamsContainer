# Esame PDS/SDP OS Internals - Versione Standard

## Domanda 1

Considera il seguente frammento di programma:

```c
#define N 32

data_t M[2*N][N];

int i,j,k;

for (k=0; k<4; k++) {
    for (i=0; i<2*N; i++) {
        for (j=k; j<N; j+=4) {
            M[i][j].diag = i-j;
        }
    }
}
```

Il codice macchina generato dal programma viene eseguito su un sistema con gestione della memoria basata su *demand paging*, 
pagine di 2KB, politica di sostituzione delle pagine basata su *Working Set* (versione esatta), con delta=10.
Assumiamo che:

* `sizeof(data_t) == 1024` sia true.
* `data_t` abbia un campo `diag` di tipo `int` (dimensione 32 bit).
* Il segmento di codice (istruzioni macchina) abbia dimensione inferiore a una pagina.
* `M` sia allocata a partire dall'indirizzo logico `0x5820C800`.
* La matrice `M` sia allocata seguendo la strategia "row major" (prima la prima riga, seguita dalla seconda riga, ...).

Rispondi alle seguenti domande:

A) **D** - Quante pagine (e frame) sono necessarie per memorizzare la matrice?<br>
**R** - Il numero di elementi per pagina è dato da:<br>
N_per_pag = Dim_pagina / sizeof(data_t) = 2 KB / 1024 B = 2048 / 1024 = 2 elementi

Loop esterno k varia da 0 a 3
Loop medio i varia da i a 2*N, dove N=32 => i da 0 64;
Loop interno j varia da 0 a 32 escluso, ma a multipli di 4, 32/4 = 8, ma meno l'ultimo che non viene eseguito => 7

m[0][0] = 0; m[0][4] = -4; m[0][8] = -8 ... m[0][28] = -28<br>
m[1][0] = 1; m[1][4] = -3; m[1][8] = -7 ... m[1][28] = -27<br>
...<br>
m[63][0] = 63; m[63][4] = 59; m[63][8] = 55 .. m[63][28] = 35<br>
ma poi k cambia, quindi avremo ulteriori cicli dove andrà a scrivere gli elementi in precedenza saltati<br>
ad esempio per k=1, si avrà j=1, poi 5 ecc che erano stati saltati, andando a popolare a tutti gli elementi.<br>
Quindi possiamo dire che in generale questo programma popola la matrice M in maniera non ottimale<br>

N_elementi_tot = righe*colonne = 64*32 = 2048 elementi;<br>
N_pagine_tot = N_elem/capienza_pag = 1024 pagine(frame);

B) **D** - Supponendo che le variabili i, j, e k siano allocate in registri (l'accesso a esse non produce riferimenti alla memoria), 
quanti riferimenti N<sub>T</sub>=N<sub>W</sub>+N<sub>R</sub> (N<sub>R</sub> per la lettura e N<sub>W</sub> per la scrittura dei dati) 
produce il programma proposto (non considerare i fetch delle istruzioni)?<br>
**R** - Abbiamo appurato che tutta la matrice viene vista e visitata una volta.<br>
N<sub>R</sub> = 0; => questo perché la lettura degli indici non produce riferimenti alla memoria<br>
N<sub>W</sub> = 2048;<br>
N<sub>T</sub>=N<sub>W</sub>+N<sub>R</sub>= 0 + 2048 = 2048

C) **D** - Calcola il numero di *page fault* generati dal programma proposto (motiva/giustifica la risposta).<br>
**R** - Dato che la politica di accesso è row-major, cioè è allocata per righe, per com'è definità attualmente la matrice: <br>
Abbiamo un working set che può contenere 10 Frame; sapendo che j salta di 4 indici per volta, i primi 10 accessi saranno sicuramente PF:<br>
Saltando 4 elementi, gli accessi saranno distanziati da 2 pagine (dato che ogni pagina può contenere 2 elementi).<br>
Abbiamo detto che le iterazioni di j sono 8, pertanto avremo sicuramente i primi 8 PF iniziali, ma cambiando riga all'iterazione <br>
di i successiva avremo cambiato nuovamente pagina, dato che salviamo per row-major (pagina [0][0] e [1][0] stanno in pagine diverse)

pertanto potremmo dedurre che i pf saranno dati da j*i*k = 8*4*64 = 2048 PF
Il motivo è che il delta=10 del Working Set è estremamente piccolo rispetto alla quantità di dati e al pattern di accesso della matrice.

Per una singola riga i e un k fisso, accediamo a 8 pagine. Queste 8 pagine rimangono nel WS.
Ma quando i cambia, si passa a una nuova riga. Ogni riga ha 32/2 = 16 pagine. Il salto da una riga all'altra è di 16 pagine.
Ogni "passata" di i (64 righe) con un k fisso causa 64 * 8 = 512 PF.
Quando k cambia (da 0 a 1, per esempio), il set di colonne a cui si accede è diverso. Anche se alcune pagine potrebbero 
essere state condivise a livello di coppia (es. M[i][0] e M[i][1] nella stessa pagina), il numero enorme di accessi 
(2048 totali) e il WS di soli 10 fanno sì che le pagine vengano continuamente rimosse e ricaricate.

In pratica, data l'estrema sparsità degli accessi nel loop j (salto di 4 elementi, che sono 2 pagine) e la transizione 
ad una nuova riga (i) che implica un salto di ben 16 pagine, il Working Set di 10 riferimenti è troppo piccolo per 
mantenere in memoria le pagine necessarie. Ogni nuovo accesso, in questo contesto, causerà molto probabilmente un Page Fault.


D) **D** - Completando opportunamente il seguente pezzo di programma, è possibile fornire un codice equivalente 
(in termini di comportamento) al precedente, producendo meno *page fault*. 
Completa il programma e calcola quanti *page fault* vengono generati (motiva la risposta).

```c
#define N 32

data_t M[2*N][N], *V;
int k;

V = &(M[0][0]);

for (k=0; k<2*N*N; k++) {
    V[k].diag = k/n - K%N;
}
```
**R** - La soluzione linearizza la matrice in un vettore, trasformando gli accessi sparsi (j+=4) in accessi sequenziali 
(k++). Questo massimizza la località spaziale (ogni elemento è adiacente al precedente), riducendo i page fault da 2048 a solo 2.
Avremo infatti un PF per la prima pagina (elementi da 0 a 1023) e un PF per la seconda (elementi da 1024 a 2047).

## Domanda 2

Considera un file system di tipo Unix, basato su *inode*, con 15 puntatori/indici (12 diretti, 1 singolo indiretto, 1 doppio indiretto e 1 triplo indiretto). 
I puntatori/indici hanno dimensione di 32 bit e i blocchi disco hanno dimensione di 4KB.<br>
Il file system risiede su una partizione disco, dove 2TB sono riservati ai blocchi dati. 
Lo spazio extra riservato ai metadati (inclusi i blocchi indice) può essere trascurato ai fini di questo esercizio.

A) **D** - È noto che il file più piccolo nel FS ha dimensione di 8MB e il file più grande ha dimensione di 8GB. 
Utilizziamo N2 per il numero di file con indicizzazione doppia e N3 per il numero di file con indicizzazione tripla. 
Calcola i valori massimi (i limiti superiori) per N2 e N3.<br>
**R** - Puntatore diretto => (12x4) 48KB di dati;<br>
Indiretto singolo: Dim Blocco / Dim puntatore => 4KB/ 32 bit => 4 * 1024 B / 4 B => 1024 Puntatori => numero per indiretto = n_puntatori * dim_blocchi => 1024 * 4KB = 4 MB<br>
Indiretto doppio: 1024 * 1024 * 4KB = 4GB; <br>
Indiretto triplo: 1024 * 1024 * 1024 * 4KB = 4TB; <br>
Dim Max file: 48 KB + 4 MB + 4 GB + 4 TB = 4.402.319.921.856 Byte (supera la dimensione del disco)<br>

N_blocchi_tot = Dim_Part / Dim_blocchi_disco = 2 TB / 4 KB = 2 * 10^12 / 4 * 10^3 = 0,5 * 10^9 => 512 * 10^6 blocchi<br>

Calcoliamo l'occupazione minima di N2 (tutti i livelli precedenti prima del doppio)<br>
N_2_MIN = 12(diretti) + 1024 (singoli) + 1 (almeno uno doppio) = 1037 blocchi;<br>
calcoliamo l'occupazione minima di N3 (tutti i livelli precedenti prima del triplo)<br>
N_3_MIN = 12 + 1024 + 1024^2 + 1 = 1M + 1037 blocchi dati

Siccome vogliamo calcolare i massimi sia per N2, che per N3, dobbiamo per entrambi i casi porre che ci sia almeno un file 
nell'altra categoria di dim minime (quindi 8MB per n3, 8GB per n2):<br>

Vincolo N_2_Max => File 8GB = 8GB/4KB = 2M blocchi<br>
Spazio disponibile per file N2 = 512M - 2M = 510 M blocchi

Vincolo N_3_Max => File 8MB = 8MB/4KB = 2K blocchi<br>
Spazio disponibile per file N3 = 512M - 2k blocchi



N<sub>2_MAX</sub> = floor(spazio_disponibile / Spazio_min_N2) = floor ((512-2M)/2K) = floor(510M / 2K) 255 K file (usa 2K e non 1037 perché il file più piccolo è di 8MB = 2K blocchi)<br>
N<sub>3_MAX</sub> = floor(spazio_disponibile / Spazio_min_N3) = floor ((512M-2K)/(1M + 1037)) = 511 file <br> 

B)**D** - Dato un file binario di dimensione 20490.5KB, calcola esattamente quanti blocchi indice e blocchi dati sta utilizzando il file. <br>
Calcola anche la frammentazione interna (per i blocchi dati).<br>

**R** -Convertiamo il file in B:<br>
Dim_file = 20490.5 KB = 20490.5 * 1024 = 20.982.272 B; <br>
Num blocchi necessari = Dim_file/Dim_blocchi_disco = ceil(20.982.272/ 4096) = ceil(5122.625) = 5123;<br>
Con i blocchi diretti e indiretto singolo abbiamo 1036 puntatori, quindi ne rimarranno 5123 - 1036 = 4087 doppi con indiretto doppio.<br>
Indiretto doppio: 4087 => 4087 * 4 KB = 16.740.352 B occupati nell'indiretto doppio;<br>
N_blocchi_indice_doppi = num_blocchi/num_puntatori_blocco = ceil(4087 / 1024) = ceil(3.99) = 4 blocchi indice indiretto doppio<br>
N_blocchi_indice_tot = 1 +1 +4 = 6 blocchi indice<br>
Frammentazione interna = Spazio allocato - dim_file = (5123 * 4 KB) - 20.982.272 B = 1536 B 

C) **D** - Considera lo stesso file della Domanda B, dove l'operazione `lseek(fd, offset, SEEK_END)` viene chiamata per posizionare 
l'offset del file (*SEEK_END* significa che l'offset si riferisce alla fine del file) per la successiva operazione di lettura/scrittura.<br>
Supponi che `fd` sia il *file descriptor* associato al file (già aperto) e che `offset = -2^20`. Calcola il numero di blocco logico 
(relativo ai blocchi del file, numerati a partire da 0) al quale la posizione viene spostata, e l'offset interno (all'interno del blocco).

**R** - La posizione assoluta sarà data da: <br>
Pos_ass = Dim_file + offset<br>
Offset = -2^20 = -1.048.576 B; <br>
Poss_ass = 20.490.5 KB - 2^20 = 20.982.272 + -1.048.576 = 19933696 B;<br>

Blocco_logico = floor(Pos_assoluta/dim_blocco) = floor(19933696/4096) = floor(4866.625) = 4866; <br>
Offset_interno = Pos_ass % Dim_blocco = 19933696%4096 = 19933696 - 4096 * floor(19933696/4096) = 19933696 - 4096 * 4866 = 2560 B = 2.5 KB

## Domanda 3

A) Un file di testo di grandi dimensioni contiene N righe di lunghezza fissa (50 caratteri per ogni riga). Dobbiamo ordinare le righe nel file usando un algoritmo di ordinamento con complessità linearitmica (O(NlogN)). A causa delle dimensioni, l'ordinamento viene implementato direttamente sul file (sfruttando la mappatura in memoria dei file o utilizzando opportunamente le primitive `seek`, `read` e `write`).

A seconda della strategia di allocazione del file system sottostante, quale complessità complessiva ci aspettiamo per il compito di ordinamento? (per ogni strategia di allocazione del file, scegli la complessità e fornisci una breve motivazione)

<table>
<thead>
<tr>
<th></th>
<th>O(N)</th>
<th>O(NlogN)</th>
<th>O(N²)</th>
<th>O(N²logN)</th>
<th>O(N³)</th>
<th>Motivazione</th>
</tr>
</thead>
<tbody>
<tr>
<td>Contiguous</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Linked list</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>FAT</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Inodes</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

B) Un grande insieme di dati è memorizzato su file utilizzando la strategia "indice e file relativo": il file indice contiene una sequenza di N record di dimensione fissa, ciascuno contenente una chiave di ricerca e un puntatore (un Indirizzo Logico) al record corrispondente nel file relativo. Il file indice è ordinato per chiavi crescenti. Il file relativo contiene N record di lunghezza variabile. I record NON sono ordinati.

A seconda della strategia di allocazione del file system sottostante, quale complessità complessiva ci aspettiamo per l'operazione di stampa di tutti i dati in ordine crescente di chiavi? (per ogni strategia di allocazione del file, scegli la complessità e fornisci una breve motivazione)

<table>
<thead>
<tr>
<th></th>
<th>O(logN)</th>
<th>O(N)</th>
<th>O(NlogN)</th>
<th>O(N²)</th>
<th>Motivazione</th>
</tr>
</thead>
<tbody>
<tr>
<td>Contiguous</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Linked list</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>FAT</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Inodes</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

## Domanda 4

Considera tre thread del kernel OS161 che implementano un'attività di trasferimento dati basata su un modello produttore/consumatore (2 produttori, 1 consumatore). I thread condividono un buffer di dati, implementato come una struttura C di tipo `struct prodConsBuf` definita come segue:

```c
struct prodConsBuf {
    data_t data;
    int dataReady;
    struct lock *pc_lk;
    struct cv *pc_cv;
};
```

Tutte le operazioni (scrittura/lettura) richiedono mutua esclusione. Quando non sono presenti dati nel buffer (quindi il buffer è vuoto), il flag `dataReady` è 0. Dopo che un produttore scrive nuovi dati nel buffer (campo `data`), imposta `dataReady` a 1 (quindi buffer pieno) e segnala il consumatore (il lavoro viene eseguito chiamando la funzione `producerWrite`).

```c
void producerWrite (struct prodConsBuf *pc, data_t *dp);
```

Il consumatore esegue iterativamente la funzione `consumerRead`.

```c
void consumerRead (struct prodConsBuf *pc, data_t *dp);
```

Rispondi alle seguenti domande:

A) La struttura condivisa può essere posizionata nello stack del thread, oppure dovrebbe essere una variabile globale o altro?
B) Poiché i campi `pc_lk` e `pc_cv` sono puntatori, dove dovrebbero essere chiamate le funzioni `lock_create()` e `cv_create()`? Nel thread produttore, nei thread consumatori? Altrove?
C) Le funzioni produttore e consumatore sono parzialmente fornite. Completa la loro implementazione dove indicato (`<1>`, `<2>` e `<3>`). Si prega di notare che dobbiamo evitare il *busy waiting*, quindi un produttore segnala il consumatore quando i dati sono pronti. Poiché un produttore potrebbe essere in attesa che il consumatore ottenga i dati precedenti, prima che al produttore sia consentito di scrivere nuovi dati, il consumatore deve anche inviare un segnale.

```c
/* le istruzioni di controllo/gestione degli errori sono omesse per semplicità */

void producerWrite (struct prodConsBuf *pc, data_t *dp) {
    /* lock per mutua esclusione */
    lock_acquire (pc->pc_lk);

    /* gestire correttamente qui il fatto che il buffer potrebbe essere pieno
       (riempito dall'altro produttore e non ancora letto dal consumatore) */
    /* <1> */

    /* copia dati: fatto qui con semplice assegnazione
       potrebbe essere usata invece una funzione apposita */
    pc->data = *dp;
    pc->dataReady = 1; /* imposta flag */

    /* segnala il consumatore */
    /* <2> */

    /* rilascia il lock e ritorna */
    lock_release (pc->pc_lk);
}

void consumerRead (struct prodConsBuf *pc, data_t *dp) {
    /* lock per mutua esclusione */
    lock_acquire (pc->pc_lk);

    while (!pc->dataReady) {
        cv_wait (pc->pc_cv, pc->pc_lk);
    }

    /* copia dati: fatto qui con semplice assegnazione */
    *dp = pc->data;
    pc->dataReady = 0; /* resetta flag */

    /* segnala un produttore in attesa, se presente */
    /* <3> */

    /* rilascia il lock e ritorna */
    lock_release (pc->pc_lk);
}
```

## Domanda 5

Considera una possibile implementazione delle chiamate di sistema `open()` e `close()` in OS161.

A) La tabella per processo si trova nella memoria utente o nella memoria kernel?
B) Supponiamo che due processi utente, in esecuzione concorrente, chiamino `write(fd,v,N)`, dove `fd` è 5 per entrambi, ti aspetti che (per ogni opzione rispondi SÌ/NO e motiva):
1) i processi scrivano sullo stesso file
2) non scrivano mai sullo stesso file
3) generalmente scrivano su file diversi ma a volte possano scrivere sullo stesso
4) per scrivere sullo stesso file, i due processi dovrebbero usare valori diversi per `fd`.

C) Data la seguente implementazione di `sys_write`:

```c
int sys_write (int fd, userptr_t buf_ptr, size_t size) {
    int i;
    char *p = (char *)buf_ptr;

    if (fd!=STDOUT_FILENO && fd!=STDERR_FILENO) {
        return file_write(fd, buf_ptr, size);
    }

    for (i=0; i<(int)size; i++) {
        putch (p[i]);
    }

    return (int)size;
}
```

Assumendo che input, output ed errore standard siano mappati sulla console (quindi non è possibile la ridirezione su file), il ciclo `for` che gestisce `stdout`/`stderr` può essere sostituito da uno (o più) dei seguenti frammenti di codice? (Per ciascuno di essi rispondi sì/no e fornisci una motivazione).

1)

```c
for (i=0; i<(int)size; i++) {
    kprintf("%c", p[i]);
}
```

2)

```c
kprintf("%s", p);
```

3)

```c
kprintf("%s", &p);
```

4)

```c
file_write(fd, p, size);
```

```
```