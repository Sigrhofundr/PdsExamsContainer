# Esame di Programmazione di Sistema - Cabodi OS - 11 Luglio 2024
---

## Domanda 1: Caratteristiche del Sistema e Gestione della Memoria

Un sistema informatico presenta le seguenti caratteristiche:
* Dimensione della memoria fisica: 512 MB
* Spazio di indirizzamento virtuale: indirizzi a 32 bit (o 16 bit)
* Dimensione della pagina: 8 KB
* Utilizza una tabella delle pagine a due livelli
* Implementa un algoritmo di sostituzione della pagina Least Recently Used (LRU)

1.  **D** - Una tabella delle pagine può essere progettata per adattare dinamicamente la sua dimensione in base al numero di pagine che un processo sta utilizzando, minimizzando così l'overhead di memoria? (SÌ/NO, Spiegare/motivare brevemente)
<br>**R** - Sì. Le tabelle delle pagine possono essere progettate per adattarsi dinamicamente, minimizzando l'overhead di memoria attraverso diverse tecniche architetturali. L'implementazione attraverso strutture gerarchiche o hash ottimizza 
l'uso della memoria allocando risorse solo quando effettivamente necessarie, bilanciando efficienza di memoria e prestazioni del sistema.<br>
2.  **D** - Un processo ha allocato più frame fisici rispetto alla dimensione del suo working set (per un dato intervallo di tempo): questo ridurrà sempre a zero il tasso di page fault? Spiegare/motivare brevemente le risposte. (SÌ/NO, Spiegare/motivare brevemente)<br>
**R** - No. Avere più frame del WS attuale non garantisce zero PF. Il WS è dinamico e cambia durante l'esecuzione del processo, richiedendo pagine diverse nel tempo. Inoltre, la contesa di memoria a livello di sistema può causare sostituzioni di pagine anche quando
il processo ha frame apparentemente sufficienti per le sue esigenze immediate.<br>
3.  **D** - Due indirizzi virtuali diversi possono mappare allo stesso indirizzo fisico in un sistema che utilizza la paginazione? (SÌ/NO, Spiegare/motivare brevemente)<br>
**R** - Sì. Questo è possibile attraverso l'utilizzo della memoria condivisa. Differenti processi possono avere differenti indirizzi virtuali che mappano lo stesso indirizzo fisico per la comunicazione tra processori.<br>
4.  **D** - L'uso di una dimensione di pagina più grande può portare a un utilizzo più efficiente della TLB nonostante i potenziali aumenti della frammentazione interna? (SÌ/NO, Spiegare/motivare brevemente)<br>
**R** - Sì. Una dimensione maggiore delle pagine può aumentare l'efficienza della TLB perché saranno necessari meno righe TLB per coprire lo stesso ammontare di spazio degli indirizzi virtuali, riducendo i TLB miss. Questo comunque porterà all'aumento della frammentazione interna.<br>
5.  **D** - La presenza di una TLB garantisce sempre un tempo di accesso alla memoria più veloce rispetto a un sistema senza TLB? (SÌ/NO, Spiegare/motivare brevemente)<br>
**R** - No. mentre una TLB generalmente aumenta i tempi di accesso alla memoria riducendo i lookups alla tabella delle pagine, in casi di un alto grado di TLB miss o di piccoli working sets che sono contenuti nella tabella delle pagine, i benefici potrebbero non essere significativi. 
Inoltre anche l'archittetura stessa del sistema influisce sulle prestazioni.<br>
6.  **D** - Se viene utilizzato l'algoritmo di sostituzione delle pagine LRU, garantisce il minor numero possibile di page fault? (SÌ/NO, Spiegare/motivare brevemente)<br>
No. LRU è un'eccellente approssimazione pratica dell'algoritmo ottimo teorico, ma non garantisce il minimo assoluto di PF a causa dei limiti teorici (vs OPT) e della dipendenza dal pattern di accesso specifico del workload.
7.  **D** - Data la seguente stringa di riferimenti di memoria per un processo (indirizzamento a byte, con indirizzi espressi in codice esadecimale) e le rispettive operazioni di lettura(R)/scrittura(W):

    `R 1F40, W 3E20, R 5D18, W 7C9E, R 2AF3, W 6B2C, R 13B2, W 24AB, R 54BC, W 12AF`

    Assumere che il sistema abbia 3 frame disponibili e utilizzi l'algoritmo di sostituzione delle pagine Least Recently Used (LRU).
    * Calcolare la stringa dei riferimenti di pagina e indicare il numero di pagina corrispondente per ogni riferimento di memoria.
    * Indicare esplicitamente per ogni frame allocato e per ogni istante/riferimento il numero di pagina e se si verifica un page fault.
    * Calcolare il numero totale di page fault che si verificano durante questa sequenza di riferimenti di memoria.

**R** - per ottenere il numero di pagina, convertiamo l'indirizzo da esadecimale a decimale, quindi dividiamo per la dimensione della pagina (8192)<br>
Ad esempio <br>R 1F40 (hex) = 8000 (dec) → 8000 ÷ 8192 = 0 → Pagina 0 <br>
W 3E20 (hex) = 15904 (dec) → 15904 ÷ 8192 = 1 → Pagina 1<br>
In alternativa, dovremmo portare in binario l'indirizzo e fare lo shift di 13 bit (perché 8Kb = 2^13) <br>
ad esempio <br>
1F40 (hex) = 0001111101000000 (bin) <br>
Shift right di 13 bit → 000 = 0 (Pagina 0) <br>
<table>
  <thead>
    <tr>
      <th></th>
      <th>R 1F40</th>
      <th>W 3E20</th>
      <th>R 5D18</th>
      <th>W 7C9E</th>
      <th>R 2AF3</th>
      <th>W 6B2C</th>
      <th>R 13B2</th>
      <th>W 24AB</th>
      <th>R 54BC</th>
      <th>W 12AF</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><b>P #</b></td>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>1</td>
      <td>3</td>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>0</td>
    </tr>
    <tr>
      <td><b>F 1</b></td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td><b>F 2</b></td>
      <td></td>
      <td>0</td>
      <td>0</td>
      <td>3</td>
      <td>3</td>
      <td>3</td>
      <td>3</td>
      <td>3</td>
      <td>2</td>
      <td>2</td>
    </tr>
    <tr>
      <td><b>F 3</b></td>
      <td></td>
      <td></td>
      <td>2</td>
      <td>2</td>
      <td>2</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td><b>PF</b></td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td></td>
      <td></td>
      <td>X</td>
      <td></td>
      <td>X</td>
      <td></td>
    </tr>
  </tbody>
</table>
<p>Total Page Fault = 6</p> 
---

## Domanda 2: File System basato su Inode

Considerare un file system di tipo Unix basato su inode, con 15 puntatori (12 diretti, 1 indiretto singolo, 1 indiretto doppio e 1 indiretto triplo). I puntatori hanno una dimensione di 32 bit e i blocchi disco hanno una dimensione di 4 KB. Il file system risiede su una partizione 
disco dove 1 TB è riservato per i blocchi dati. Lo spazio extra riservato per i metadati (inclusi i blocchi indice) può essere trascurato ai fini di questo esercizio.
<br>
A) **D** - Calcolare la dimensione massima del file supportata da questo file system.<br>
**R** : <br>
Puntatore diretto => (12x4) 48KB di dati;<br>
Indiretto singolo: Dim Blocco / Dim puntatore => 4KB/ 32 bit => 4 * 1024 B / 4 B => 1024 Puntatori => numero per indiretto = n_puntatori * dim_blocchi => 1024 * 4KB = 4 MB<br>
Indiretto doppio: 1024 * 1024 * 4KB = 4GB; <br>
Indiretto triplo: 1024 * 1024 * 1024 * 4KB = 4TB; <br>
Dim Max file: 48 KB + 4 MB + 4 GB + 4 TB = 4.402.319.921.856 Byte (supera la dimensione del disco)<br>
B) **D** - Dato un file binario di dimensione 25.600 KB, calcolare esattamente quanti blocchi indice e blocchi dati sta utilizzando il file. Calcolare anche la frammentazione interna (per i blocchi dati).<br>
**R** - Ci serviranno 14 puntatori (escludiamo il triplo) e stiamo escludendo i metadati: <br>
Num blocchi necessari = Dim_file/Dim_blocchi_disco = (25600 * 1024) / (4 * 1024) = 25600/4 = 6400 blocchi<br>
Sommando i blocchi del puntatore diretto e dell'indiretto singolo otteniamo => 1024 + 12 => 1036 blocchi => 4MB + 48KB = 4.243.456 B<br>
Blocchi rimanenti => 6400 - 1036 = 5364 blocchi negli indiretti doppi <br>
Indiretto doppio: 5364 => 5364 * 4 KB = 21456KB = 21.970.944 B ; inoltre dal numero dei puntatori ci ricaviamo il numero di blocchi indice => 5364/1024 = 5.23 => 6 blocchi indice<br>
Questi sommati ai 2 (1+1) dei livelli precedenti, TOT BLOCCHI INDICE = 1 + 1 + 6 = 8; <br>
File originale = 25600 KB = 25600 * 1024 = 26.214.400 B <br>
La somma dei bytes totali viene senza delta => nessuna frammentazione interna per le ipotesi poste.<br>
C) **D** - Supponiamo che venga chiamata un'operazione `lseek(fd, offset, SEEK_END)` per posizionare l'offset del file per una successiva operazione di lettura/scrittura. 
Dato un file binario di dimensione 10 GB e un offset di -1.048.576 byte (1 MB) dalla fine del file, calcolare il numero di blocco logico (relativo ai blocchi del file, numerati a partire da 0) 
a cui la posizione viene spostata.<br>
**R** - Intanto convertiamo i dati: <br>
Dimensione file = 10 GB = 10 * 1024 * 1024 * 10124 = 10.737.418.240 B = 2.621.440 blocchi <br>
Offset = -1.048.576 byte = -1.048.576 byte / 4096 = -256 blocchi <br>
Posizione assoluta = DIM_FILE + offset = 10.737.418.240 + (-1.048.576) = 10.736.369.664 <br>
Blocco logico = floor(Posizione_assoluta/Dimensione_blocco) = 10.736.369.664 / 4096 = 2.621.184° blocco <br>
Offset_nel_blocco = Posizione assoluta % dim_blocco = 0
---

## Domanda 3: Gestione della Memoria di Massa e I/O

Considerare un sistema informatico che utilizza una combinazione di unità a disco rigido (HDD) e unità a stato solido (SSD) per l'archiviazione di massa. Il sistema incorpora anche vari dispositivi di I/O gestiti da un sottosistema di I/O.

1.  Una configurazione RAID 0 (striping) può migliorare l'affidabilità dei dati rispetto a una singola configurazione HDD? (SÌ/NO, Spiegare/motivare brevemente)
2.  È possibile che un SSD soffra di problemi di frammentazione simili a quelli riscontrati dagli HDD? (SÌ/NO, Spiegare/motivare brevemente)
3.  È sempre più efficiente utilizzare il Direct Memory Access (DMA) per tutti i tipi di operazioni di I/O rispetto all'I/O guidato da interrupt? (SÌ/NO, Spiegare/motivare brevemente)
4.  Il polling è un metodo più efficiente per gestire le operazioni di I/O rispetto all'utilizzo degli interrupt in un ambiente di rete ad alta velocità? (SÌ/NO, Spiegare/motivare brevemente)
5.  Uno scheduler di I/O ben progettato può migliorare significativamente le prestazioni di una configurazione RAID 5 rispetto a uno scheduler di I/O mal progettato? (SÌ/NO, Spiegare/motivare brevemente)
6.  È possibile che un'operazione di I/O su un SSD abbia sempre una latenza inferiore rispetto alla stessa operazione su un HDD? (SÌ/NO, Spiegare/motivare brevemente)

---

## Domanda 4: Sistema oS161 e Gestione dell'Indirizzamento

Un sistema oS161 è dato, in esecuzione su un simulatore MIPS sys161 con 8MB di RAM. È noto che il processo P1 ha uno spazio di indirizzamento con `as->as_pbase1`, `as->as_pbase2`, `as->as_vbase1`, `as->as_vbase2`, `as->as_npages1`, `as->as_npages2` con i seguenti valori: `0x200000`, `0x100000`, `0x4000`, `0x8000`, 3, 4.

Per ciascuno dei seguenti indirizzi fisici, convertire in un indirizzo logico del kernel. Nel caso in cui l'indirizzo sia allocato a P1, convertirlo in un indirizzo logico utente:
* `0x100A00`
* `0x10A0F0`
* `0x206500`
* `0x202D00`

La funzione oS161 `load_elf` imposta lo spazio di indirizzamento di un nuovo processo utente. In diverse fasi, `load_elf` chiama `load_segment`, `as_prepare_load`, `as_complete_load`, `as_define_region`. Rispondere alle seguenti domande:
* Quale funzione viene chiamata per allocare lo spazio di indirizzamento nella memoria fisica?
* Quale funzione viene chiamata per impostare gli indirizzi logici e le dimensioni dei segmenti di codice e dati?
* Quale funzione legge il segmento dati dal file elf?
* Quale funzione legge il segmento codice dal file elf?

---

## Domanda 5: Funzioni `sys_exit` e `sys_waitpid` in oS161

Considerare le funzioni `sys_exit` e `sys_waitpid` implementate nel lab4. Rispondere alle seguenti domande:

* Sono già presenti nella versione base di oS161? (SÌ/NO)
* Sono chiamate di sistema che possono essere chiamate dai processi utente? (SÌ/NO)
* Nel lab4 un processo deve essere identificato da un `pid`.
    * Un `pid` è un puntatore? (SÌ/NO)
    * Il `pid` è associato a un processo al momento del bootstrap? (SÌ/NO)
    * La funzione `common_prog` crasha senza implementare e usare `waitpid` (o funzioni correlate)? (SÌ/NO)
* La funzione `proc_destroy` viene chiamata all'interno di:
    * la chiamata di sistema `exit`? (SÌ/NO)
    * la chiamata di sistema `waitpid`? (SÌ/NO)
    * è chiamata dalla funzione `thread_exit`? (SÌ/NO)